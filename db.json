{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"themes/one-paper/source/css/a11y-dark.min.css","path":"css/a11y-dark.min.css","modified":1,"renderable":1},{"_id":"themes/one-paper/source/css/fonts.css","path":"css/fonts.css","modified":1,"renderable":1},{"_id":"themes/one-paper/source/css/markdown.css","path":"css/markdown.css","modified":1,"renderable":1},{"_id":"themes/one-paper/source/css/reset.css","path":"css/reset.css","modified":1,"renderable":1},{"_id":"themes/one-paper/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-600.woff","path":"fonts/montserrat-v23-latin-600.woff","modified":1,"renderable":1},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-600.woff2","path":"fonts/montserrat-v23-latin-600.woff2","modified":1,"renderable":1},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-600italic.woff","path":"fonts/montserrat-v23-latin-600italic.woff","modified":1,"renderable":1},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-600italic.woff2","path":"fonts/montserrat-v23-latin-600italic.woff2","modified":1,"renderable":1},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-italic.woff","path":"fonts/montserrat-v23-latin-italic.woff","modified":1,"renderable":1},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-italic.woff2","path":"fonts/montserrat-v23-latin-italic.woff2","modified":1,"renderable":1},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-regular.woff","path":"fonts/montserrat-v23-latin-regular.woff","modified":1,"renderable":1},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-regular.woff2","path":"fonts/montserrat-v23-latin-regular.woff2","modified":1,"renderable":1},{"_id":"themes/one-paper/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/one-paper/source/img/one-paper.png","path":"img/one-paper.png","modified":1,"renderable":1},{"_id":"themes/one-paper/source/js/highlight.min.js","path":"js/highlight.min.js","modified":1,"renderable":1},{"_id":"themes/one-paper/source/js/highlightjs-line-numbers.js","path":"js/highlightjs-line-numbers.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/Vue的双向绑定和单向数据流.md","hash":"e87dd6a4532f8ef27562b899a1c6afbe91cd8933","modified":1654342700578},{"_id":"source/_posts/background-size-和background-cover的缩写.md","hash":"d8658b3c9bcd24b2f651b4200d3f117fe2f87b0e","modified":1654342700579},{"_id":"source/_posts/plugin.md","hash":"8a669c306fadd9e7ea8f45891d37ad7f3d6c1172","modified":1654342700580},{"_id":"source/_posts/依赖版本锁不锁.md","hash":"e4bc2a287780f64c5da9b59d780285c28c1f04cd","modified":1654342700581},{"_id":"source/_posts/切换node版本.md","hash":"470ffe7d26d1c04559f53698ded6181fedaf2213","modified":1654342700582},{"_id":"source/_posts/如何实现一个babel-plugin.md","hash":"058d930354541c9824d7c9d31fd0ae7cb42cfdec","modified":1654342700584},{"_id":"source/_posts/react-18.md","hash":"b494c0c7e1fd1738f8087a3fe81d47b54ce4b626","modified":1654342700581},{"_id":"source/_posts/如何在git本地配置多个SSH-keys.md","hash":"92126cef2f28bfc33ebded119f9323f6ef3ae008","modified":1654342700583},{"_id":"source/_posts/github-卡片统计.md","hash":"6f9d90678901819f14dc7359d295751d9f3c22c2","modified":1654346709779},{"_id":"source/_posts/我的第一篇文章.md","hash":"e5f5e71b1f4d404f527dc2e4a7fba8f8aa5d66e7","modified":1654342700586},{"_id":"source/_posts/编译流程.md","hash":"af4d484bdc8c01171f0eae9ee4f4a1dfb9cb596a","modified":1654346463293},{"_id":"themes/one-paper/_config.yml","hash":"13a88d6e9d9ad7c8363b852cfc681e458c119116","modified":1654342700588},{"_id":"themes/one-paper/layout/archive.ejs","hash":"ff0d592a498756894f9ca969f1f2f57135c58adc","modified":1654342700595},{"_id":"themes/one-paper/layout/.DS_Store","hash":"08a1b17f850059d18759b3e71604904807708396","modified":1654157641611},{"_id":"themes/one-paper/layout/index.ejs","hash":"f2be1e56d3de2f5fe3111136753b13737429dc64","modified":1654342700596},{"_id":"themes/one-paper/layout/layout.ejs","hash":"68d1bb31fccbe9810b9c8a6cd54b53938e0318a2","modified":1654342700596},{"_id":"themes/one-paper/layout/post.ejs","hash":"5a70cb257c3112327750b4d988d36539a43d5ca8","modified":1654342700597},{"_id":"themes/one-paper/LICENSE","hash":"aad1dcb7deccd18a89508fa2ad78101dafa10cc9","modified":1654342700586},{"_id":"themes/one-paper/layout/_partial/footer.ejs","hash":"7bc76c7d8bc1f4c6b2d78bf6dc9702229909b4d8","modified":1654342700589},{"_id":"themes/one-paper/README.md","hash":"39b4a0d2b37a27f5d247339b8e851ed4d89e0851","modified":1654342700587},{"_id":"themes/one-paper/layout/_partial/head.ejs","hash":"5e089c0f24607334d34215948f9bfba2569c5eea","modified":1654342700590},{"_id":"themes/one-paper/layout/_partial/header.ejs","hash":"2b54259f35942eeb1b99482c2a4517152fc87f0c","modified":1654342700591},{"_id":"themes/one-paper/layout/_partial/paginator.ejs","hash":"980bf0a0be798c19df4b0827aa4b90b35c872425","modified":1654342700592},{"_id":"themes/one-paper/layout/_partial/post-header.ejs","hash":"f6fa471122459b25a9948405d72cb5f197d2fc25","modified":1654342700593},{"_id":"themes/one-paper/source/css/a11y-dark.min.css","hash":"e0a3294faa7dfa1eae300caea5a01f438b643b93","modified":1654342700598},{"_id":"themes/one-paper/source/css/reset.css","hash":"f6184d3f74dc704f077ca4e0b91003652a9db978","modified":1654342700599},{"_id":"themes/one-paper/source/css/fonts.css","hash":"bd6171c8de8d9f4efafca3802c4d20099d7fca1c","modified":1654342700598},{"_id":"themes/one-paper/source/css/markdown.css","hash":"8116b5049847ca524b99e10a501b945dcff0f29d","modified":1654342700599},{"_id":"themes/one-paper/source/css/style.css","hash":"db3ccfa28bfd57d13c5c509e82b447a6d17e6b58","modified":1654342700599},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-600.woff","hash":"925d9f095488dc77dd84e8414422f0113f4628a9","modified":1654342700600},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-600italic.woff","hash":"c0e80c18fac1cd10469c4f922ad92e81fc8b3b94","modified":1654342700601},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-600italic.woff2","hash":"1f24e9edcccd42d4694a4020d6a8f9b9cb28f471","modified":1654342700602},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-600.woff2","hash":"2fe30978041c41a2994ac0fd491e83d32a3203b7","modified":1654342700601},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-italic.woff","hash":"fca5ee87a17c57eb53265da1c2c75db7305ad69c","modified":1654342700602},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-regular.woff","hash":"285adda1da1fc15583ad53160d66032aeccb45ea","modified":1654342700603},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-italic.woff2","hash":"ce1eae3f714702a82c1e9c05b5ba302a9e91ac20","modified":1654342700602},{"_id":"themes/one-paper/source/fonts/montserrat-v23-latin-regular.woff2","hash":"f7eefafb7bfdc6b5572714fa267268b845a67cf4","modified":1654342700603},{"_id":"themes/one-paper/source/img/favicon.png","hash":"0845678601e8b144ae45c448a25650f4d3d2182d","modified":1654342700604},{"_id":"themes/one-paper/source/js/highlightjs-line-numbers.js","hash":"690e96133591495fa847d828573bd0576b2d168a","modified":1654342700612},{"_id":"themes/one-paper/source/js/highlight.min.js","hash":"d264ad16bdf39cfec2b06c20223b87fcb37ad27b","modified":1654342700611},{"_id":"themes/one-paper/source/img/one-paper.png","hash":"eadd349e5316a154099cb06e41abe5a105940e37","modified":1654342700610},{"_id":"public/2022/06/04/github-卡片统计/index.html","hash":"bd01fdbe6604d01012d7eb2e5365f95ae2a59e5a","modified":1654347010313},{"_id":"public/2022/06/04/编译流程/index.html","hash":"a23f83ebc58947b3a1e5c42dfac42e27968d190e","modified":1654347010313},{"_id":"public/2022/06/04/如何在git本地配置多个SSH-keys/index.html","hash":"063df9fe62332281d23796d9e8b01c1738176e15","modified":1654347010313},{"_id":"public/2022/06/04/plugin/index.html","hash":"8648c4f093cb69834d3edbe079d4911e7079915c","modified":1654347010313},{"_id":"public/2022/06/04/如何实现一个babel-plugin/index.html","hash":"a0ca3669415052156bf762d79d3232d77f0f544a","modified":1654347010313},{"_id":"public/2022/06/04/react-18/index.html","hash":"d86544286bd4bab292a6a129cf0b73fe376ae985","modified":1654347010313},{"_id":"public/2022/06/04/依赖版本锁不锁/index.html","hash":"c924a2fcbc144a50eee3c17c01a4f3920912da42","modified":1654347010313},{"_id":"public/2022/06/04/background-size-和background-cover的缩写/index.html","hash":"efbb02f7281b5ae00f32f249e079455e9a8747df","modified":1654347010313},{"_id":"public/2022/06/04/切换node版本/index.html","hash":"7710c8927a62134b25c01da0d399cbe9e0d91b02","modified":1654347010313},{"_id":"public/2022/06/03/Vue的双向绑定和单向数据流/index.html","hash":"539c9789beb7b80f930140d52d1d2ee6eae399a6","modified":1654347010313},{"_id":"public/2022/06/02/我的第一篇文章/index.html","hash":"6bed2c7e9197d253ce927a1fc79b0fbde3638c13","modified":1654347010313},{"_id":"public/archives/index.html","hash":"228b33a42b85f4698836d848c081c313512814fa","modified":1654347010313},{"_id":"public/archives/page/2/index.html","hash":"e3238ef64a81f29c37912b3fb99d8199910d5e2a","modified":1654347010313},{"_id":"public/archives/2022/index.html","hash":"1624c9dc04559595894c38a585407cecbdce9050","modified":1654347010313},{"_id":"public/archives/2022/page/2/index.html","hash":"7073d19ee2c95e78ad108b572216e833e9161082","modified":1654347010313},{"_id":"public/archives/2022/06/index.html","hash":"b41e2a0b6c59131a150a776d9b438c1e843a7e4e","modified":1654347010313},{"_id":"public/archives/2022/06/page/2/index.html","hash":"73612b5d43c6d9f629bd3d66dfcb7de5cf77b26f","modified":1654347010313},{"_id":"public/categories/技术/index.html","hash":"0f0b56603bb69cd57fb7179661784390a9059863","modified":1654347010313},{"_id":"public/page/2/index.html","hash":"fc4d97efc0df6a5bf9b275faa9048a77f1167829","modified":1654347010313},{"_id":"public/index.html","hash":"692e2222acf8b2cab1a9536bd3cb9f20b0750a40","modified":1654347010313},{"_id":"public/tags/Vue/index.html","hash":"3eb1ad24e50a17d5602a21011dba079c4dd42097","modified":1654347010313},{"_id":"public/tags/CSS/index.html","hash":"bd847a81ba69fb7a2c501bf2502ee14ca5716764","modified":1654347010313},{"_id":"public/tags/git/index.html","hash":"00e07749a1c1be296aeed58013eebba4b80ecad2","modified":1654347010313},{"_id":"public/tags/babel/index.html","hash":"ba839b4ac48b8ead1a39f7562366eb50d5af78d0","modified":1654347010313},{"_id":"public/tags/react-18/index.html","hash":"5080636b2adcf39ad5551c023934ecdedd9b9ebc","modified":1654347010313},{"_id":"public/tags/node/index.html","hash":"81b7633d617aac3b4768d3f47d2f58b0ac2fcee7","modified":1654347010313},{"_id":"public/tags/REPL/index.html","hash":"0f0b56603bb69cd57fb7179661784390a9059863","modified":1654347010313},{"_id":"public/fonts/montserrat-v23-latin-600.woff2","hash":"2fe30978041c41a2994ac0fd491e83d32a3203b7","modified":1654347010313},{"_id":"public/fonts/montserrat-v23-latin-600italic.woff","hash":"c0e80c18fac1cd10469c4f922ad92e81fc8b3b94","modified":1654347010313},{"_id":"public/fonts/montserrat-v23-latin-600.woff","hash":"925d9f095488dc77dd84e8414422f0113f4628a9","modified":1654347010313},{"_id":"public/fonts/montserrat-v23-latin-600italic.woff2","hash":"1f24e9edcccd42d4694a4020d6a8f9b9cb28f471","modified":1654347010313},{"_id":"public/fonts/montserrat-v23-latin-italic.woff2","hash":"ce1eae3f714702a82c1e9c05b5ba302a9e91ac20","modified":1654347010313},{"_id":"public/fonts/montserrat-v23-latin-regular.woff","hash":"285adda1da1fc15583ad53160d66032aeccb45ea","modified":1654347010313},{"_id":"public/img/favicon.png","hash":"0845678601e8b144ae45c448a25650f4d3d2182d","modified":1654347010313},{"_id":"public/fonts/montserrat-v23-latin-italic.woff","hash":"fca5ee87a17c57eb53265da1c2c75db7305ad69c","modified":1654347010313},{"_id":"public/fonts/montserrat-v23-latin-regular.woff2","hash":"f7eefafb7bfdc6b5572714fa267268b845a67cf4","modified":1654347010313},{"_id":"public/css/a11y-dark.min.css","hash":"e0a3294faa7dfa1eae300caea5a01f438b643b93","modified":1654347010313},{"_id":"public/css/markdown.css","hash":"8116b5049847ca524b99e10a501b945dcff0f29d","modified":1654347010313},{"_id":"public/css/fonts.css","hash":"bd6171c8de8d9f4efafca3802c4d20099d7fca1c","modified":1654347010313},{"_id":"public/css/reset.css","hash":"f6184d3f74dc704f077ca4e0b91003652a9db978","modified":1654347010313},{"_id":"public/css/style.css","hash":"db3ccfa28bfd57d13c5c509e82b447a6d17e6b58","modified":1654347010313},{"_id":"public/js/highlightjs-line-numbers.js","hash":"690e96133591495fa847d828573bd0576b2d168a","modified":1654347010313},{"_id":"public/img/one-paper.png","hash":"eadd349e5316a154099cb06e41abe5a105940e37","modified":1654347010313},{"_id":"public/js/highlight.min.js","hash":"d264ad16bdf39cfec2b06c20223b87fcb37ad27b","modified":1654347010313}],"Category":[{"name":"技术","_id":"cl3zvhuz9000jkiwx5uuuh4pp"}],"Data":[],"Page":[],"Post":[{"title":"Vue的双向绑定和单向数据流","date":"2022-06-03T08:29:00.000Z","_content":"<div style= \"border: 1px solid #ddd; box-shadow: 2px 2px 2px #ddd; padding:10px;\">五一假期在家补了课，看到双向绑定与单向数据流的概念。瓦特，我之前以为Vue的V-model就是双向数据流，其实不然,下面让我仔细来看看\n</div>\n\n### 双向绑定\n简而言之，双向绑定就是model的更新会触发view的更新，view的更新会触发model的更新，它们的作用是相互的\n![双向绑定](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/3/16a7caae1cc36343~tplv-t2oaga2asx-image.image)\n### 单向数据流\n简而言之，单向数据流就是model的更新会触发view的更新，view的更新不会触发model的更新，它们的作用是单向的\n![单向数据流](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/3/16a7d4aacf9dccf9~tplv-t2oaga2asx-image.image)\n\n这不是废话吗，谁都知道的\n\n下面就是真正的干货了，板凳坐好\n<ul>\n<li>Vue是单向数据流，不是双向绑定</li>\n<li>Vue的双向绑定不过是语法糖</li>\n<li>Object.definePropert是用来做响应式更新的</li>\n</ul>\n\n### v-model的实现原理\n* 放在组件上\n\n父组件\n\n```\n\n  <AnalysisSub v-model=\"phoneInfo\" :zip-code.sync=\"zipCode\" />\n  \n```\n子组件\n```\n<template>\n  <div>\n    <input\n      :value=\"phoneInfo.phone\"\n      type=\"number\"\n      placeholder=\"手机号\"\n      @input=\"handlePhoneChange\"\n    />\n    <input\n      :value=\"zipCode\"\n      type=\"number\"\n      placeholder=\"邮编\"\n      @input=\"handleZipCodeChange\"\n    />\n  </div>\n</template>\n<script>\nexport default {\n  name: \"PersonalInfo\",\n  model: {\n    prop: \"phoneInfo\", // 默认 value\n    event: \"change\" // 默认 input\n  },\n  props: {\n    phoneInfo: Object,\n    zipCode: String\n  },\n  methods: {\n    handlePhoneChange(e) {\n      this.$emit(\"change\", {\n        ...this.phoneInfo,\n        phone: e.target.value\n      });\n    },\n    handleZipCodeChange(e) {\n      this.$emit(\"update:zipCode\", e.target.value);\n    }\n  }\n};\n</script>\n```\n\n父组件的写法等同于\n```\n <AnalysisSub :phone-info=\"phoneInfo\" @change=\"val => (phoneInfo = val)\"\n    :zip-code=\"zipCode\"  @update:zipCode=\"val => (zipCode = val)\"/>\n```\n* 放在input元素上\n\n其实上文已经体现了\n```\n<input v-model=“phoneInfo.phone”/>\n<input :value=\"PhoneInfo.phone\" @input=\"val => { PhoneInfo.phone = val }\"\n```\n以上两句是相等的\n### TIPS\n[model](https://cn.vuejs.org/v2/api/#model) 2.2.0+\n>允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。\n\n[.sync修饰符](https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6) 2.3.0+\n>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。\n\n### 总结\n所以说呢， vue还是单向数据流，v-model只不过是语法糖，它是`:value=\"sth\"`和` @change=\"val => sth = val\"`的简写形式。我们通常在面试当中被提问，Vue是怎么实现数据响应式更新的，面试官期望听到的回答是通过`Object.defineProperty() `的`get`和`set`方法来实现响应式更新。 \n\nv-model和.sync修饰符分别在组件单个属性、多个属性需要双向绑定下使用，这是二者使用的场景","source":"_posts/Vue的双向绑定和单向数据流.md","raw":"---\ntitle: Vue的双向绑定和单向数据流\ndate: 2022-06-03 16:29:00\ntags: Vue\n---\n<div style= \"border: 1px solid #ddd; box-shadow: 2px 2px 2px #ddd; padding:10px;\">五一假期在家补了课，看到双向绑定与单向数据流的概念。瓦特，我之前以为Vue的V-model就是双向数据流，其实不然,下面让我仔细来看看\n</div>\n\n### 双向绑定\n简而言之，双向绑定就是model的更新会触发view的更新，view的更新会触发model的更新，它们的作用是相互的\n![双向绑定](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/3/16a7caae1cc36343~tplv-t2oaga2asx-image.image)\n### 单向数据流\n简而言之，单向数据流就是model的更新会触发view的更新，view的更新不会触发model的更新，它们的作用是单向的\n![单向数据流](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/3/16a7d4aacf9dccf9~tplv-t2oaga2asx-image.image)\n\n这不是废话吗，谁都知道的\n\n下面就是真正的干货了，板凳坐好\n<ul>\n<li>Vue是单向数据流，不是双向绑定</li>\n<li>Vue的双向绑定不过是语法糖</li>\n<li>Object.definePropert是用来做响应式更新的</li>\n</ul>\n\n### v-model的实现原理\n* 放在组件上\n\n父组件\n\n```\n\n  <AnalysisSub v-model=\"phoneInfo\" :zip-code.sync=\"zipCode\" />\n  \n```\n子组件\n```\n<template>\n  <div>\n    <input\n      :value=\"phoneInfo.phone\"\n      type=\"number\"\n      placeholder=\"手机号\"\n      @input=\"handlePhoneChange\"\n    />\n    <input\n      :value=\"zipCode\"\n      type=\"number\"\n      placeholder=\"邮编\"\n      @input=\"handleZipCodeChange\"\n    />\n  </div>\n</template>\n<script>\nexport default {\n  name: \"PersonalInfo\",\n  model: {\n    prop: \"phoneInfo\", // 默认 value\n    event: \"change\" // 默认 input\n  },\n  props: {\n    phoneInfo: Object,\n    zipCode: String\n  },\n  methods: {\n    handlePhoneChange(e) {\n      this.$emit(\"change\", {\n        ...this.phoneInfo,\n        phone: e.target.value\n      });\n    },\n    handleZipCodeChange(e) {\n      this.$emit(\"update:zipCode\", e.target.value);\n    }\n  }\n};\n</script>\n```\n\n父组件的写法等同于\n```\n <AnalysisSub :phone-info=\"phoneInfo\" @change=\"val => (phoneInfo = val)\"\n    :zip-code=\"zipCode\"  @update:zipCode=\"val => (zipCode = val)\"/>\n```\n* 放在input元素上\n\n其实上文已经体现了\n```\n<input v-model=“phoneInfo.phone”/>\n<input :value=\"PhoneInfo.phone\" @input=\"val => { PhoneInfo.phone = val }\"\n```\n以上两句是相等的\n### TIPS\n[model](https://cn.vuejs.org/v2/api/#model) 2.2.0+\n>允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。\n\n[.sync修饰符](https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6) 2.3.0+\n>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。\n\n### 总结\n所以说呢， vue还是单向数据流，v-model只不过是语法糖，它是`:value=\"sth\"`和` @change=\"val => sth = val\"`的简写形式。我们通常在面试当中被提问，Vue是怎么实现数据响应式更新的，面试官期望听到的回答是通过`Object.defineProperty() `的`get`和`set`方法来实现响应式更新。 \n\nv-model和.sync修饰符分别在组件单个属性、多个属性需要双向绑定下使用，这是二者使用的场景","slug":"Vue的双向绑定和单向数据流","published":1,"updated":"2022-06-04T11:38:20.578Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3zvhuys0000kiwx1c4uewpz","content":"<div style= \"border: 1px solid #ddd; box-shadow: 2px 2px 2px #ddd; padding:10px;\">五一假期在家补了课，看到双向绑定与单向数据流的概念。瓦特，我之前以为Vue的V-model就是双向数据流，其实不然,下面让我仔细来看看\n</div>\n\n<h3 id=\"双向绑定\"><a href=\"#双向绑定\" class=\"headerlink\" title=\"双向绑定\"></a>双向绑定</h3><p>简而言之，双向绑定就是model的更新会触发view的更新，view的更新会触发model的更新，它们的作用是相互的<br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/3/16a7caae1cc36343~tplv-t2oaga2asx-image.image\" alt=\"双向绑定\"></p>\n<h3 id=\"单向数据流\"><a href=\"#单向数据流\" class=\"headerlink\" title=\"单向数据流\"></a>单向数据流</h3><p>简而言之，单向数据流就是model的更新会触发view的更新，view的更新不会触发model的更新，它们的作用是单向的<br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/3/16a7d4aacf9dccf9~tplv-t2oaga2asx-image.image\" alt=\"单向数据流\"></p>\n<p>这不是废话吗，谁都知道的</p>\n<p>下面就是真正的干货了，板凳坐好</p>\n<ul>\n<li>Vue是单向数据流，不是双向绑定</li>\n<li>Vue的双向绑定不过是语法糖</li>\n<li>Object.definePropert是用来做响应式更新的</li>\n</ul>\n\n<h3 id=\"v-model的实现原理\"><a href=\"#v-model的实现原理\" class=\"headerlink\" title=\"v-model的实现原理\"></a>v-model的实现原理</h3><ul>\n<li>放在组件上</li>\n</ul>\n<p>父组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;AnalysisSub v-model=&quot;phoneInfo&quot; :zip-code.sync=&quot;zipCode&quot; /&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>子组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;input</span><br><span class=\"line\">      :value=&quot;phoneInfo.phone&quot;</span><br><span class=\"line\">      type=&quot;number&quot;</span><br><span class=\"line\">      placeholder=&quot;手机号&quot;</span><br><span class=\"line\">      @input=&quot;handlePhoneChange&quot;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">    &lt;input</span><br><span class=\"line\">      :value=&quot;zipCode&quot;</span><br><span class=\"line\">      type=&quot;number&quot;</span><br><span class=\"line\">      placeholder=&quot;邮编&quot;</span><br><span class=\"line\">      @input=&quot;handleZipCodeChange&quot;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;PersonalInfo&quot;,</span><br><span class=\"line\">  model: &#123;</span><br><span class=\"line\">    prop: &quot;phoneInfo&quot;, // 默认 value</span><br><span class=\"line\">    event: &quot;change&quot; // 默认 input</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    phoneInfo: Object,</span><br><span class=\"line\">    zipCode: String</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    handlePhoneChange(e) &#123;</span><br><span class=\"line\">      this.$emit(&quot;change&quot;, &#123;</span><br><span class=\"line\">        ...this.phoneInfo,</span><br><span class=\"line\">        phone: e.target.value</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleZipCodeChange(e) &#123;</span><br><span class=\"line\">      this.$emit(&quot;update:zipCode&quot;, e.target.value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>父组件的写法等同于</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;AnalysisSub :phone-info=&quot;phoneInfo&quot; @change=&quot;val =&gt; (phoneInfo = val)&quot;</span><br><span class=\"line\">   :zip-code=&quot;zipCode&quot;  @update:zipCode=&quot;val =&gt; (zipCode = val)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>放在input元素上</li>\n</ul>\n<p>其实上文已经体现了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model=“phoneInfo.phone”/&gt;</span><br><span class=\"line\">&lt;input :value=&quot;PhoneInfo.phone&quot; @input=&quot;val =&gt; &#123; PhoneInfo.phone = val &#125;&quot;</span><br></pre></td></tr></table></figure>\n<p>以上两句是相等的</p>\n<h3 id=\"TIPS\"><a href=\"#TIPS\" class=\"headerlink\" title=\"TIPS\"></a>TIPS</h3><p><a href=\"https://cn.vuejs.org/v2/api/#model\">model</a> 2.2.0+</p>\n<blockquote>\n<p>允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。</p>\n</blockquote>\n<p><a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6\">.sync修饰符</a> 2.3.0+</p>\n<blockquote>\n<p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>所以说呢， vue还是单向数据流，v-model只不过是语法糖，它是<code>:value=&quot;sth&quot;</code>和<code> @change=&quot;val =&gt; sth = val&quot;</code>的简写形式。我们通常在面试当中被提问，Vue是怎么实现数据响应式更新的，面试官期望听到的回答是通过<code>Object.defineProperty() </code>的<code>get</code>和<code>set</code>方法来实现响应式更新。 </p>\n<p>v-model和.sync修饰符分别在组件单个属性、多个属性需要双向绑定下使用，这是二者使用的场景</p>\n","site":{"data":{}},"excerpt":"","more":"<div style= \"border: 1px solid #ddd; box-shadow: 2px 2px 2px #ddd; padding:10px;\">五一假期在家补了课，看到双向绑定与单向数据流的概念。瓦特，我之前以为Vue的V-model就是双向数据流，其实不然,下面让我仔细来看看\n</div>\n\n<h3 id=\"双向绑定\"><a href=\"#双向绑定\" class=\"headerlink\" title=\"双向绑定\"></a>双向绑定</h3><p>简而言之，双向绑定就是model的更新会触发view的更新，view的更新会触发model的更新，它们的作用是相互的<br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/3/16a7caae1cc36343~tplv-t2oaga2asx-image.image\" alt=\"双向绑定\"></p>\n<h3 id=\"单向数据流\"><a href=\"#单向数据流\" class=\"headerlink\" title=\"单向数据流\"></a>单向数据流</h3><p>简而言之，单向数据流就是model的更新会触发view的更新，view的更新不会触发model的更新，它们的作用是单向的<br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/3/16a7d4aacf9dccf9~tplv-t2oaga2asx-image.image\" alt=\"单向数据流\"></p>\n<p>这不是废话吗，谁都知道的</p>\n<p>下面就是真正的干货了，板凳坐好</p>\n<ul>\n<li>Vue是单向数据流，不是双向绑定</li>\n<li>Vue的双向绑定不过是语法糖</li>\n<li>Object.definePropert是用来做响应式更新的</li>\n</ul>\n\n<h3 id=\"v-model的实现原理\"><a href=\"#v-model的实现原理\" class=\"headerlink\" title=\"v-model的实现原理\"></a>v-model的实现原理</h3><ul>\n<li>放在组件上</li>\n</ul>\n<p>父组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;AnalysisSub v-model=&quot;phoneInfo&quot; :zip-code.sync=&quot;zipCode&quot; /&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>子组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;input</span><br><span class=\"line\">      :value=&quot;phoneInfo.phone&quot;</span><br><span class=\"line\">      type=&quot;number&quot;</span><br><span class=\"line\">      placeholder=&quot;手机号&quot;</span><br><span class=\"line\">      @input=&quot;handlePhoneChange&quot;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">    &lt;input</span><br><span class=\"line\">      :value=&quot;zipCode&quot;</span><br><span class=\"line\">      type=&quot;number&quot;</span><br><span class=\"line\">      placeholder=&quot;邮编&quot;</span><br><span class=\"line\">      @input=&quot;handleZipCodeChange&quot;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;PersonalInfo&quot;,</span><br><span class=\"line\">  model: &#123;</span><br><span class=\"line\">    prop: &quot;phoneInfo&quot;, // 默认 value</span><br><span class=\"line\">    event: &quot;change&quot; // 默认 input</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    phoneInfo: Object,</span><br><span class=\"line\">    zipCode: String</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    handlePhoneChange(e) &#123;</span><br><span class=\"line\">      this.$emit(&quot;change&quot;, &#123;</span><br><span class=\"line\">        ...this.phoneInfo,</span><br><span class=\"line\">        phone: e.target.value</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleZipCodeChange(e) &#123;</span><br><span class=\"line\">      this.$emit(&quot;update:zipCode&quot;, e.target.value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>父组件的写法等同于</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;AnalysisSub :phone-info=&quot;phoneInfo&quot; @change=&quot;val =&gt; (phoneInfo = val)&quot;</span><br><span class=\"line\">   :zip-code=&quot;zipCode&quot;  @update:zipCode=&quot;val =&gt; (zipCode = val)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>放在input元素上</li>\n</ul>\n<p>其实上文已经体现了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model=“phoneInfo.phone”/&gt;</span><br><span class=\"line\">&lt;input :value=&quot;PhoneInfo.phone&quot; @input=&quot;val =&gt; &#123; PhoneInfo.phone = val &#125;&quot;</span><br></pre></td></tr></table></figure>\n<p>以上两句是相等的</p>\n<h3 id=\"TIPS\"><a href=\"#TIPS\" class=\"headerlink\" title=\"TIPS\"></a>TIPS</h3><p><a href=\"https://cn.vuejs.org/v2/api/#model\">model</a> 2.2.0+</p>\n<blockquote>\n<p>允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。</p>\n</blockquote>\n<p><a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6\">.sync修饰符</a> 2.3.0+</p>\n<blockquote>\n<p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>所以说呢， vue还是单向数据流，v-model只不过是语法糖，它是<code>:value=&quot;sth&quot;</code>和<code> @change=&quot;val =&gt; sth = val&quot;</code>的简写形式。我们通常在面试当中被提问，Vue是怎么实现数据响应式更新的，面试官期望听到的回答是通过<code>Object.defineProperty() </code>的<code>get</code>和<code>set</code>方法来实现响应式更新。 </p>\n<p>v-model和.sync修饰符分别在组件单个属性、多个属性需要双向绑定下使用，这是二者使用的场景</p>\n"},{"title":"background-size 和background-cover的缩写","date":"2022-06-04T03:03:31.000Z","_content":"\n## 简介\n \n `background`的缩写其实在工作中经常遇到，但是由于属性颇多，会弄混淆，遂记录下\n\n``` css\nbackground: center / contain no-repeat url(\"../../media/examples/firefox-logo.svg\"), \n#eee 35% url(\"../../media/examples/lizard.png\");\n```\n\n以上代码我是从[MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background)拷贝的，能判断以上属性是什么属性的缩写吗。我们从浏览器`Styles` 截图\n\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f609962e432b4288a61c827f9357aece~tplv-k3u1fbpfcp-watermark.image?)\n\n代码中是有两张背景图片（日常工作没有用两张图片叠加在一起）。其实`no-repeat` 、`url`、`#eee` 这些都特别好判断，关键是`center/ container`、`35%` 不好区分。 他们是`background-postion`和`background-size`这两个属性，如果两个都缩写的话，必定要用`/`分割起来。`/`前面代表 background-position ，`/`后面是`background-size`。 如果没有用上`/`,则代表着`background-postion`属性\n  \n  \n ## 附上css样式属性\n \n ###  background-position\n  \n > 含义：定义x、y的坐标\n \n 属性值（没想到，一搜发现有这么多写法），有一到四个值的写法，可以看到不管是是几个值的语法，都有`length`和`percentage`的写法，所以常常回合`background-size`弄混\n \n![FireShot Capture 011 - background-position - CSS（层叠样式表） - MDN - developer.mozilla.org.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b77cd9fb67340d88367b6c6672a68e2~tplv-k3u1fbpfcp-watermark.image?)\n\n ### background-size\n  \n> 含义： 设置图片背景的大小\n属性值： \n\n1、 length \n2、 percentage \n3、 auto\n4、 cover\n5、container\n\n \n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0209ec91b6943c39198433ccf793b43~tplv-k3u1fbpfcp-watermark.image?)\n \n \n日常工作中最常用的缩写组合，应该就是`background: url(xxx) no-repeat center / cover #eee`类似的语法了\n \n \n","source":"_posts/background-size-和background-cover的缩写.md","raw":"---\ntitle: background-size 和background-cover的缩写\ndate: 2022-06-04 11:03:31\ntags: CSS\n---\n\n## 简介\n \n `background`的缩写其实在工作中经常遇到，但是由于属性颇多，会弄混淆，遂记录下\n\n``` css\nbackground: center / contain no-repeat url(\"../../media/examples/firefox-logo.svg\"), \n#eee 35% url(\"../../media/examples/lizard.png\");\n```\n\n以上代码我是从[MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background)拷贝的，能判断以上属性是什么属性的缩写吗。我们从浏览器`Styles` 截图\n\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f609962e432b4288a61c827f9357aece~tplv-k3u1fbpfcp-watermark.image?)\n\n代码中是有两张背景图片（日常工作没有用两张图片叠加在一起）。其实`no-repeat` 、`url`、`#eee` 这些都特别好判断，关键是`center/ container`、`35%` 不好区分。 他们是`background-postion`和`background-size`这两个属性，如果两个都缩写的话，必定要用`/`分割起来。`/`前面代表 background-position ，`/`后面是`background-size`。 如果没有用上`/`,则代表着`background-postion`属性\n  \n  \n ## 附上css样式属性\n \n ###  background-position\n  \n > 含义：定义x、y的坐标\n \n 属性值（没想到，一搜发现有这么多写法），有一到四个值的写法，可以看到不管是是几个值的语法，都有`length`和`percentage`的写法，所以常常回合`background-size`弄混\n \n![FireShot Capture 011 - background-position - CSS（层叠样式表） - MDN - developer.mozilla.org.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b77cd9fb67340d88367b6c6672a68e2~tplv-k3u1fbpfcp-watermark.image?)\n\n ### background-size\n  \n> 含义： 设置图片背景的大小\n属性值： \n\n1、 length \n2、 percentage \n3、 auto\n4、 cover\n5、container\n\n \n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0209ec91b6943c39198433ccf793b43~tplv-k3u1fbpfcp-watermark.image?)\n \n \n日常工作中最常用的缩写组合，应该就是`background: url(xxx) no-repeat center / cover #eee`类似的语法了\n \n \n","slug":"background-size-和background-cover的缩写","published":1,"updated":"2022-06-04T11:38:20.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3zvhuyx0001kiwxbsnd6qrl","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p> <code>background</code>的缩写其实在工作中经常遇到，但是由于属性颇多，会弄混淆，遂记录下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">background</span>: center / contain no-repeat <span class=\"built_in\">url</span>(<span class=\"string\">&quot;../../media/examples/firefox-logo.svg&quot;</span>), </span><br><span class=\"line\"><span class=\"number\">#eee</span> <span class=\"number\">35%</span> <span class=\"built_in\">url</span>(<span class=\"string\">&quot;../../media/examples/lizard.png&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>以上代码我是从<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/background\">MDN</a>拷贝的，能判断以上属性是什么属性的缩写吗。我们从浏览器<code>Styles</code> 截图</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f609962e432b4288a61c827f9357aece~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>代码中是有两张背景图片（日常工作没有用两张图片叠加在一起）。其实<code>no-repeat</code> 、<code>url</code>、<code>#eee</code> 这些都特别好判断，关键是<code>center/ container</code>、<code>35%</code> 不好区分。 他们是<code>background-postion</code>和<code>background-size</code>这两个属性，如果两个都缩写的话，必定要用<code>/</code>分割起来。<code>/</code>前面代表 background-position ，<code>/</code>后面是<code>background-size</code>。 如果没有用上<code>/</code>,则代表着<code>background-postion</code>属性</p>\n<h2 id=\"附上css样式属性\"><a href=\"#附上css样式属性\" class=\"headerlink\" title=\"附上css样式属性\"></a>附上css样式属性</h2><h3 id=\"background-position\"><a href=\"#background-position\" class=\"headerlink\" title=\"background-position\"></a>background-position</h3><blockquote>\n<p>含义：定义x、y的坐标</p>\n</blockquote>\n<p> 属性值（没想到，一搜发现有这么多写法），有一到四个值的写法，可以看到不管是是几个值的语法，都有<code>length</code>和<code>percentage</code>的写法，所以常常回合<code>background-size</code>弄混</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b77cd9fb67340d88367b6c6672a68e2~tplv-k3u1fbpfcp-watermark.image\" alt=\"FireShot Capture 011 - background-position - CSS（层叠样式表） - MDN - developer.mozilla.org.png\"></p>\n<h3 id=\"background-size\"><a href=\"#background-size\" class=\"headerlink\" title=\"background-size\"></a>background-size</h3><blockquote>\n<p>含义： 设置图片背景的大小<br>属性值： </p>\n</blockquote>\n<p>1、 length<br>2、 percentage<br>3、 auto<br>4、 cover<br>5、container</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0209ec91b6943c39198433ccf793b43~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>日常工作中最常用的缩写组合，应该就是<code>background: url(xxx) no-repeat center / cover #eee</code>类似的语法了</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p> <code>background</code>的缩写其实在工作中经常遇到，但是由于属性颇多，会弄混淆，遂记录下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">background</span>: center / contain no-repeat <span class=\"built_in\">url</span>(<span class=\"string\">&quot;../../media/examples/firefox-logo.svg&quot;</span>), </span><br><span class=\"line\"><span class=\"number\">#eee</span> <span class=\"number\">35%</span> <span class=\"built_in\">url</span>(<span class=\"string\">&quot;../../media/examples/lizard.png&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>以上代码我是从<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/background\">MDN</a>拷贝的，能判断以上属性是什么属性的缩写吗。我们从浏览器<code>Styles</code> 截图</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f609962e432b4288a61c827f9357aece~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>代码中是有两张背景图片（日常工作没有用两张图片叠加在一起）。其实<code>no-repeat</code> 、<code>url</code>、<code>#eee</code> 这些都特别好判断，关键是<code>center/ container</code>、<code>35%</code> 不好区分。 他们是<code>background-postion</code>和<code>background-size</code>这两个属性，如果两个都缩写的话，必定要用<code>/</code>分割起来。<code>/</code>前面代表 background-position ，<code>/</code>后面是<code>background-size</code>。 如果没有用上<code>/</code>,则代表着<code>background-postion</code>属性</p>\n<h2 id=\"附上css样式属性\"><a href=\"#附上css样式属性\" class=\"headerlink\" title=\"附上css样式属性\"></a>附上css样式属性</h2><h3 id=\"background-position\"><a href=\"#background-position\" class=\"headerlink\" title=\"background-position\"></a>background-position</h3><blockquote>\n<p>含义：定义x、y的坐标</p>\n</blockquote>\n<p> 属性值（没想到，一搜发现有这么多写法），有一到四个值的写法，可以看到不管是是几个值的语法，都有<code>length</code>和<code>percentage</code>的写法，所以常常回合<code>background-size</code>弄混</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b77cd9fb67340d88367b6c6672a68e2~tplv-k3u1fbpfcp-watermark.image\" alt=\"FireShot Capture 011 - background-position - CSS（层叠样式表） - MDN - developer.mozilla.org.png\"></p>\n<h3 id=\"background-size\"><a href=\"#background-size\" class=\"headerlink\" title=\"background-size\"></a>background-size</h3><blockquote>\n<p>含义： 设置图片背景的大小<br>属性值： </p>\n</blockquote>\n<p>1、 length<br>2、 percentage<br>3、 auto<br>4、 cover<br>5、container</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0209ec91b6943c39198433ccf793b43~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>日常工作中最常用的缩写组合，应该就是<code>background: url(xxx) no-repeat center / cover #eee</code>类似的语法了</p>\n"},{"title":"github 卡片统计","date":"2022-06-04T12:44:37.000Z","_content":"\n## 小秘诀\n\n新建一个与自己 github 同名的仓库，因为同名的仓库是一个特殊的仓库，README.md 将会出现在首页\n\n## github 卡片统计\n\n### 利用第一个开源库[github-readme-stats](https://github.com/MissNanLan/github-readme-stats)\n\n#### GitHub Extra Pins\n\n``` js\n/api/pin?username=anuraghazra&repo=github-readme-stats\n```\n[点击这里测试](https://github-readme-stats.vercel.app/api/pin?username=anuraghazra&repo=github-readme-stats)\n\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36d85205514944dd8fc39e364b543305~tplv-k3u1fbpfcp-watermark.image)\n\n#### GitHub Stats Card\n\n``` \n/api?username=MissNanLan\n```\n\n[点击这里测试](https://github-readme-stats.vercel.app/api?username=MissNanLan)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f63f96fe50834db49a7f6b1a935f58a8~tplv-k3u1fbpfcp-watermark.image)\n\n- 隐藏个人统计资料\n\n  > Options: &hide=stars,commits,prs,issues,contribs\n\n- 将私人贡献计数添加到总提交计数中\n\n  > Options: &count_private=true\n\n- 显示 icon\n\n  > Options: &show_icons=true\n\n- 显示主题\n  > Options: &theme=dark, radical, merko, gruvbox, tokyonight, onedark, cobalt, synthwave, highcontrast, dracula\n  - 自定义主题\n\n#### Top Languages Card\n\n```\n/api/top-langs/username=MissNanLan\n```\n[点击这里测试](https://github-readme-stats.vercel.app/api/top-langs/?username=MissNanLan)\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b9d77176bd49cb946aca71885ec637~tplv-k3u1fbpfcp-watermark.image)\n\n#### Wakatime Week Stats\n\n[wakatime](https://wakatime.com/)\n\n```\n/api/wakatime?usename= 你的Wakatime用户名\n```\n\n[点击这里测试](https://github-readme-stats.vercel.app/api/wakatime?username=MissNanLan)\n\n1、 在 `Wakatime` 安装自己 IDE 工具，比如 `VScode`\n\n2、 在自己本地的 `VSCode` 安装 WakaTime 插件`⌘ + Shift + P`\n\n![image](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fbc9d80eb8f405a8d45f2ae4be86950~tplv-k3u1fbpfcp-watermark.image)\n\n### 利用 vercel 自己部署\n\n1、 在[vercel](https://vercel.com/)用 github 登陆\n\n2、 fork [github-readme-stats](https://github.com/MissNanLan/github-readme-stats)\n\n3、 点击`New Project`选择你仓库下的`github-readme-stats`\n\n4、 配置环境变量`PAT_1`,这一步很重要，在部署前先配置（我之前都是在构建前再去配置，导致没有生效，这里谁有解答可以告知）\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f5a8b190790400a9c649312b8a6b52f~tplv-k3u1fbpfcp-watermark.image)\n\n`NAME` 是`PAT_1`,`Value`是github的个人授权token\n\n5、创建Personal access token。 \n\n在 github ->settings->Developer settings>Personal access tokens->New personal access token，最后点击`Generate Token`即可\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a211e4f6689949de9375b4b5de9a4472~tplv-k3u1fbpfcp-watermark.image)\n\n6、 点击查看 `domain`，可以自定义\n","source":"_posts/github-卡片统计.md","raw":"---\ntitle: github 卡片统计\ndate: 2022-06-04 20:44:37\ntags: git\n---\n\n## 小秘诀\n\n新建一个与自己 github 同名的仓库，因为同名的仓库是一个特殊的仓库，README.md 将会出现在首页\n\n## github 卡片统计\n\n### 利用第一个开源库[github-readme-stats](https://github.com/MissNanLan/github-readme-stats)\n\n#### GitHub Extra Pins\n\n``` js\n/api/pin?username=anuraghazra&repo=github-readme-stats\n```\n[点击这里测试](https://github-readme-stats.vercel.app/api/pin?username=anuraghazra&repo=github-readme-stats)\n\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36d85205514944dd8fc39e364b543305~tplv-k3u1fbpfcp-watermark.image)\n\n#### GitHub Stats Card\n\n``` \n/api?username=MissNanLan\n```\n\n[点击这里测试](https://github-readme-stats.vercel.app/api?username=MissNanLan)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f63f96fe50834db49a7f6b1a935f58a8~tplv-k3u1fbpfcp-watermark.image)\n\n- 隐藏个人统计资料\n\n  > Options: &hide=stars,commits,prs,issues,contribs\n\n- 将私人贡献计数添加到总提交计数中\n\n  > Options: &count_private=true\n\n- 显示 icon\n\n  > Options: &show_icons=true\n\n- 显示主题\n  > Options: &theme=dark, radical, merko, gruvbox, tokyonight, onedark, cobalt, synthwave, highcontrast, dracula\n  - 自定义主题\n\n#### Top Languages Card\n\n```\n/api/top-langs/username=MissNanLan\n```\n[点击这里测试](https://github-readme-stats.vercel.app/api/top-langs/?username=MissNanLan)\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b9d77176bd49cb946aca71885ec637~tplv-k3u1fbpfcp-watermark.image)\n\n#### Wakatime Week Stats\n\n[wakatime](https://wakatime.com/)\n\n```\n/api/wakatime?usename= 你的Wakatime用户名\n```\n\n[点击这里测试](https://github-readme-stats.vercel.app/api/wakatime?username=MissNanLan)\n\n1、 在 `Wakatime` 安装自己 IDE 工具，比如 `VScode`\n\n2、 在自己本地的 `VSCode` 安装 WakaTime 插件`⌘ + Shift + P`\n\n![image](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fbc9d80eb8f405a8d45f2ae4be86950~tplv-k3u1fbpfcp-watermark.image)\n\n### 利用 vercel 自己部署\n\n1、 在[vercel](https://vercel.com/)用 github 登陆\n\n2、 fork [github-readme-stats](https://github.com/MissNanLan/github-readme-stats)\n\n3、 点击`New Project`选择你仓库下的`github-readme-stats`\n\n4、 配置环境变量`PAT_1`,这一步很重要，在部署前先配置（我之前都是在构建前再去配置，导致没有生效，这里谁有解答可以告知）\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f5a8b190790400a9c649312b8a6b52f~tplv-k3u1fbpfcp-watermark.image)\n\n`NAME` 是`PAT_1`,`Value`是github的个人授权token\n\n5、创建Personal access token。 \n\n在 github ->settings->Developer settings>Personal access tokens->New personal access token，最后点击`Generate Token`即可\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a211e4f6689949de9375b4b5de9a4472~tplv-k3u1fbpfcp-watermark.image)\n\n6、 点击查看 `domain`，可以自定义\n","slug":"github-卡片统计","published":1,"updated":"2022-06-04T12:45:09.779Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3zvhuz00003kiwxak9t8ute","content":"<h2 id=\"小秘诀\"><a href=\"#小秘诀\" class=\"headerlink\" title=\"小秘诀\"></a>小秘诀</h2><p>新建一个与自己 github 同名的仓库，因为同名的仓库是一个特殊的仓库，README.md 将会出现在首页</p>\n<h2 id=\"github-卡片统计\"><a href=\"#github-卡片统计\" class=\"headerlink\" title=\"github 卡片统计\"></a>github 卡片统计</h2><h3 id=\"利用第一个开源库github-readme-stats\"><a href=\"#利用第一个开源库github-readme-stats\" class=\"headerlink\" title=\"利用第一个开源库github-readme-stats\"></a>利用第一个开源库<a href=\"https://github.com/MissNanLan/github-readme-stats\">github-readme-stats</a></h3><h4 id=\"GitHub-Extra-Pins\"><a href=\"#GitHub-Extra-Pins\" class=\"headerlink\" title=\"GitHub Extra Pins\"></a>GitHub Extra Pins</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/api/pin?username=anuraghazra&amp;repo=github-readme-stats</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github-readme-stats.vercel.app/api/pin?username=anuraghazra&repo=github-readme-stats\">点击这里测试</a></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36d85205514944dd8fc39e364b543305~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h4 id=\"GitHub-Stats-Card\"><a href=\"#GitHub-Stats-Card\" class=\"headerlink\" title=\"GitHub Stats Card\"></a>GitHub Stats Card</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/api?username=MissNanLan</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github-readme-stats.vercel.app/api?username=MissNanLan\">点击这里测试</a></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f63f96fe50834db49a7f6b1a935f58a8~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li><p>隐藏个人统计资料</p>\n<blockquote>\n<p>Options: &amp;hide&#x3D;stars,commits,prs,issues,contribs</p>\n</blockquote>\n</li>\n<li><p>将私人贡献计数添加到总提交计数中</p>\n<blockquote>\n<p>Options: &amp;count_private&#x3D;true</p>\n</blockquote>\n</li>\n<li><p>显示 icon</p>\n<blockquote>\n<p>Options: &amp;show_icons&#x3D;true</p>\n</blockquote>\n</li>\n<li><p>显示主题</p>\n<blockquote>\n<p>Options: &amp;theme&#x3D;dark, radical, merko, gruvbox, tokyonight, onedark, cobalt, synthwave, highcontrast, dracula</p>\n</blockquote>\n<ul>\n<li>自定义主题</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Top-Languages-Card\"><a href=\"#Top-Languages-Card\" class=\"headerlink\" title=\"Top Languages Card\"></a>Top Languages Card</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/api/top-langs/username=MissNanLan</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github-readme-stats.vercel.app/api/top-langs/?username=MissNanLan\">点击这里测试</a></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b9d77176bd49cb946aca71885ec637~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h4 id=\"Wakatime-Week-Stats\"><a href=\"#Wakatime-Week-Stats\" class=\"headerlink\" title=\"Wakatime Week Stats\"></a>Wakatime Week Stats</h4><p><a href=\"https://wakatime.com/\">wakatime</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/api/wakatime?usename= 你的Wakatime用户名</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github-readme-stats.vercel.app/api/wakatime?username=MissNanLan\">点击这里测试</a></p>\n<p>1、 在 <code>Wakatime</code> 安装自己 IDE 工具，比如 <code>VScode</code></p>\n<p>2、 在自己本地的 <code>VSCode</code> 安装 WakaTime 插件<code>⌘ + Shift + P</code></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fbc9d80eb8f405a8d45f2ae4be86950~tplv-k3u1fbpfcp-watermark.image\" alt=\"image\"></p>\n<h3 id=\"利用-vercel-自己部署\"><a href=\"#利用-vercel-自己部署\" class=\"headerlink\" title=\"利用 vercel 自己部署\"></a>利用 vercel 自己部署</h3><p>1、 在<a href=\"https://vercel.com/\">vercel</a>用 github 登陆</p>\n<p>2、 fork <a href=\"https://github.com/MissNanLan/github-readme-stats\">github-readme-stats</a></p>\n<p>3、 点击<code>New Project</code>选择你仓库下的<code>github-readme-stats</code></p>\n<p>4、 配置环境变量<code>PAT_1</code>,这一步很重要，在部署前先配置（我之前都是在构建前再去配置，导致没有生效，这里谁有解答可以告知）</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f5a8b190790400a9c649312b8a6b52f~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p><code>NAME</code> 是<code>PAT_1</code>,<code>Value</code>是github的个人授权token</p>\n<p>5、创建Personal access token。 </p>\n<p>在 github -&gt;settings-&gt;Developer settings&gt;Personal access tokens-&gt;New personal access token，最后点击<code>Generate Token</code>即可</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a211e4f6689949de9375b4b5de9a4472~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>6、 点击查看 <code>domain</code>，可以自定义</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"小秘诀\"><a href=\"#小秘诀\" class=\"headerlink\" title=\"小秘诀\"></a>小秘诀</h2><p>新建一个与自己 github 同名的仓库，因为同名的仓库是一个特殊的仓库，README.md 将会出现在首页</p>\n<h2 id=\"github-卡片统计\"><a href=\"#github-卡片统计\" class=\"headerlink\" title=\"github 卡片统计\"></a>github 卡片统计</h2><h3 id=\"利用第一个开源库github-readme-stats\"><a href=\"#利用第一个开源库github-readme-stats\" class=\"headerlink\" title=\"利用第一个开源库github-readme-stats\"></a>利用第一个开源库<a href=\"https://github.com/MissNanLan/github-readme-stats\">github-readme-stats</a></h3><h4 id=\"GitHub-Extra-Pins\"><a href=\"#GitHub-Extra-Pins\" class=\"headerlink\" title=\"GitHub Extra Pins\"></a>GitHub Extra Pins</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/api/pin?username=anuraghazra&amp;repo=github-readme-stats</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github-readme-stats.vercel.app/api/pin?username=anuraghazra&repo=github-readme-stats\">点击这里测试</a></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36d85205514944dd8fc39e364b543305~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h4 id=\"GitHub-Stats-Card\"><a href=\"#GitHub-Stats-Card\" class=\"headerlink\" title=\"GitHub Stats Card\"></a>GitHub Stats Card</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/api?username=MissNanLan</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github-readme-stats.vercel.app/api?username=MissNanLan\">点击这里测试</a></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f63f96fe50834db49a7f6b1a935f58a8~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li><p>隐藏个人统计资料</p>\n<blockquote>\n<p>Options: &amp;hide&#x3D;stars,commits,prs,issues,contribs</p>\n</blockquote>\n</li>\n<li><p>将私人贡献计数添加到总提交计数中</p>\n<blockquote>\n<p>Options: &amp;count_private&#x3D;true</p>\n</blockquote>\n</li>\n<li><p>显示 icon</p>\n<blockquote>\n<p>Options: &amp;show_icons&#x3D;true</p>\n</blockquote>\n</li>\n<li><p>显示主题</p>\n<blockquote>\n<p>Options: &amp;theme&#x3D;dark, radical, merko, gruvbox, tokyonight, onedark, cobalt, synthwave, highcontrast, dracula</p>\n</blockquote>\n<ul>\n<li>自定义主题</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Top-Languages-Card\"><a href=\"#Top-Languages-Card\" class=\"headerlink\" title=\"Top Languages Card\"></a>Top Languages Card</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/api/top-langs/username=MissNanLan</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github-readme-stats.vercel.app/api/top-langs/?username=MissNanLan\">点击这里测试</a></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b9d77176bd49cb946aca71885ec637~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h4 id=\"Wakatime-Week-Stats\"><a href=\"#Wakatime-Week-Stats\" class=\"headerlink\" title=\"Wakatime Week Stats\"></a>Wakatime Week Stats</h4><p><a href=\"https://wakatime.com/\">wakatime</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/api/wakatime?usename= 你的Wakatime用户名</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github-readme-stats.vercel.app/api/wakatime?username=MissNanLan\">点击这里测试</a></p>\n<p>1、 在 <code>Wakatime</code> 安装自己 IDE 工具，比如 <code>VScode</code></p>\n<p>2、 在自己本地的 <code>VSCode</code> 安装 WakaTime 插件<code>⌘ + Shift + P</code></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fbc9d80eb8f405a8d45f2ae4be86950~tplv-k3u1fbpfcp-watermark.image\" alt=\"image\"></p>\n<h3 id=\"利用-vercel-自己部署\"><a href=\"#利用-vercel-自己部署\" class=\"headerlink\" title=\"利用 vercel 自己部署\"></a>利用 vercel 自己部署</h3><p>1、 在<a href=\"https://vercel.com/\">vercel</a>用 github 登陆</p>\n<p>2、 fork <a href=\"https://github.com/MissNanLan/github-readme-stats\">github-readme-stats</a></p>\n<p>3、 点击<code>New Project</code>选择你仓库下的<code>github-readme-stats</code></p>\n<p>4、 配置环境变量<code>PAT_1</code>,这一步很重要，在部署前先配置（我之前都是在构建前再去配置，导致没有生效，这里谁有解答可以告知）</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f5a8b190790400a9c649312b8a6b52f~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p><code>NAME</code> 是<code>PAT_1</code>,<code>Value</code>是github的个人授权token</p>\n<p>5、创建Personal access token。 </p>\n<p>在 github -&gt;settings-&gt;Developer settings&gt;Personal access tokens-&gt;New personal access token，最后点击<code>Generate Token</code>即可</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a211e4f6689949de9375b4b5de9a4472~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>6、 点击查看 <code>domain</code>，可以自定义</p>\n"},{"title":"plugin","date":"2022-06-04T10:28:51.000Z","_content":"\n举一个例子，以写一个自动生成API文档为主\n\n## plugin\n\n### 调用插件\n\n``` js\n// index.js\nconst { transformFromAstSync } = require('@babel/core');\nconst  parser = require('@babel/parser');\nconst autoDocumentPlugin = require('./plugin/auto-document-plugin');\nconst fs = require('fs');\nconst path = require('path');\n\n// 读取文件\nconst sourceCode = fs.readFileSync(path.join(__dirname, './sourceCode.ts'), {\n    encoding: 'utf-8'\n});\n\n// 转成AST\nconst ast = parser.parse(sourceCode, {\n    sourceType: 'unambiguous',\n    plugins: ['typescript']\n});\n\n// 插件使用\nconst { code } = transformFromAstSync(ast, sourceCode, {\n    plugins: [[autoDocumentPlugin, {\n        outputDir: path.resolve(__dirname, './docs'),\n        format: 'markdown'// html / json\n    }]]\n});\n\n```\n\n### plugin模板\n\nplugin 有两种形式\n\n####  一个函数返回一个对象的格式\n\n``` js\n// xx-plugin.js\nconst { declare } = require('@babel/helper-plugin-utils');\n// api:  babel 的 api，\n// options: 传给plugin的参数\n// dirname： 目录名字\nconst xxPlugin = declare((api, options, dirname) => {\n    api.assertVersion(7);\n    const xxPlugin = declare((api, options, dirname) => {\n        api.assertVersion(7);\n        // name 插件的名字\n        // inherits 指定继承某个插件，和当前插件的 options 合并，通过 Object.assign 的方式。\n        // pre 遍历前调用\n        // visitor 指定 traverse 时调用的函数。\n        // post 遍历后调用\n        // manipulateOptions 用于修改 options，是在插件里面修改配置的方式，比如 babel-plugin-syntax-xx, 一般都会修改 parser options\n        return {\n            name: \"proposal-export-namespace-from\",\n            inherits: syntaxExportNamespaceFrom.default,\n            pre(file) {\n                // 代码逻辑\n            },\n            visitor: {\n                FunctionDeclaration(path, state) {\n                    // 代码逻辑\n                },\n            },\n            manipulateOptions(opts, parserOpts) {   \n                // 告诉 parser 要 parse xxx这个语法,如jsx \n                 parserOpts.plugins.push(\"xxx\");\n            },\n            post(file) {\n                // 代码逻辑\n            }\n        }\n    })\n})\n```\n 在babel官网找了几个插件的写法\n \n [babel-plugin-proposal-export-default-from](https://github.com/babel/babel/blob/main/packages/babel-plugin-proposal-export-default-from/src/index.ts)\n \n [babel-plugin-proposal-function-bind](https://github.com/babel/babel/blob/main/packages/babel-plugin-proposal-function-bind/src/index.ts)\n \n [babel-plugin-proposal-numeric-separator](https://github.com/babel/babel/blob/main/packages/babel-plugin-proposal-numeric-separator/src/index.ts)\n \n [babel-plugin-syntax-export-default-from](https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from)\n \n #### 直接返回一个对象\n \n 这种方式的插件形式用于不需要处理参数的情况,这种我在官网还没有找到\n \n  ``` js\nexport default plugin = {\n  pre(state) {\n    this.cache = new Map();\n  },\n  visitor: {\n    StringLiteral(path, state) {\n      this.cache.set(path.node.value, 1);\n    },\n  },\n  post(state) {\n    console.log(this.cache);\n  },\n};\n  ```\n \n\n### visitor模式\n\n>visitor模式（访问者模式），作为设计模式的其中一种。访问者模式解决的是**数据**与**数据的操作方法**之间的耦合，将数据的操作方法独立于数据，使其可以自由演变。因此访问这更适合于那些**数据稳定**，但是数据的操作方法一遍的环境下。因此当操作方环境改变时，可以自由修改操作方法以适应操作环境，而不用修改原数据，实现操作方法的扩展。\n\n对应到 babel traverse 的实现，就是 AST(数据) 和 visitor（有很多操作方法） 分离，在 traverse（遍历）AST 的时候，调用注册的 visitor 来对其进行处理\n\n\n#### 路径（path）和作用域（scope）\n\n``` js\npath:NodePath\n```\n\n> babel AST 中只包含源码的一些信息，但是操作 AST 时要拿到父节点的信息，并且也需要对 AST 增删改的方法，这些都在 path 对象里。\n\n>scope 是作用域信息，javascript 中能生成作用域的就是模块、函数、块等，而且作用域之间会形成嵌套关系，也就是作用域链。babel 在遍历的过程中会生成作用域链保存在 path.scope 中。\n\n \n path api太强大， 要多用才熟悉\n \n\n## @babel/types\n\n[@babel/types](https://babeljs.io/docs/en/babel-types)\n\n\n## 总结\n\n大致了解怎么去写一个babel插件，在转成AST后，在transform阶段运用设计模式的访问者模式（数据和数据的操作方法解耦），然后通过path相关api去实现逻辑，path的类型是`NodePath`,这个里面包含了AST的path 和scope（作用域链），通过对api的各种操作，实现我们要的结果\n\n``` js\nvisitor: { \nExportNamedDeclaration(path) { \n  const { node, scope } = path;\n}\n```\n\n## 参考\n\n掘金小册[babel插件通关秘籍](https://juejin.cn/book/6946117847848321055/section/6946582521672892456)\n\n[babel-handbook](https://github.com/jamiebuilds/babel-handbook)","source":"_posts/plugin.md","raw":"---\ntitle: plugin\ndate: 2022-06-04 18:28:51\ntags: babel\n---\n\n举一个例子，以写一个自动生成API文档为主\n\n## plugin\n\n### 调用插件\n\n``` js\n// index.js\nconst { transformFromAstSync } = require('@babel/core');\nconst  parser = require('@babel/parser');\nconst autoDocumentPlugin = require('./plugin/auto-document-plugin');\nconst fs = require('fs');\nconst path = require('path');\n\n// 读取文件\nconst sourceCode = fs.readFileSync(path.join(__dirname, './sourceCode.ts'), {\n    encoding: 'utf-8'\n});\n\n// 转成AST\nconst ast = parser.parse(sourceCode, {\n    sourceType: 'unambiguous',\n    plugins: ['typescript']\n});\n\n// 插件使用\nconst { code } = transformFromAstSync(ast, sourceCode, {\n    plugins: [[autoDocumentPlugin, {\n        outputDir: path.resolve(__dirname, './docs'),\n        format: 'markdown'// html / json\n    }]]\n});\n\n```\n\n### plugin模板\n\nplugin 有两种形式\n\n####  一个函数返回一个对象的格式\n\n``` js\n// xx-plugin.js\nconst { declare } = require('@babel/helper-plugin-utils');\n// api:  babel 的 api，\n// options: 传给plugin的参数\n// dirname： 目录名字\nconst xxPlugin = declare((api, options, dirname) => {\n    api.assertVersion(7);\n    const xxPlugin = declare((api, options, dirname) => {\n        api.assertVersion(7);\n        // name 插件的名字\n        // inherits 指定继承某个插件，和当前插件的 options 合并，通过 Object.assign 的方式。\n        // pre 遍历前调用\n        // visitor 指定 traverse 时调用的函数。\n        // post 遍历后调用\n        // manipulateOptions 用于修改 options，是在插件里面修改配置的方式，比如 babel-plugin-syntax-xx, 一般都会修改 parser options\n        return {\n            name: \"proposal-export-namespace-from\",\n            inherits: syntaxExportNamespaceFrom.default,\n            pre(file) {\n                // 代码逻辑\n            },\n            visitor: {\n                FunctionDeclaration(path, state) {\n                    // 代码逻辑\n                },\n            },\n            manipulateOptions(opts, parserOpts) {   \n                // 告诉 parser 要 parse xxx这个语法,如jsx \n                 parserOpts.plugins.push(\"xxx\");\n            },\n            post(file) {\n                // 代码逻辑\n            }\n        }\n    })\n})\n```\n 在babel官网找了几个插件的写法\n \n [babel-plugin-proposal-export-default-from](https://github.com/babel/babel/blob/main/packages/babel-plugin-proposal-export-default-from/src/index.ts)\n \n [babel-plugin-proposal-function-bind](https://github.com/babel/babel/blob/main/packages/babel-plugin-proposal-function-bind/src/index.ts)\n \n [babel-plugin-proposal-numeric-separator](https://github.com/babel/babel/blob/main/packages/babel-plugin-proposal-numeric-separator/src/index.ts)\n \n [babel-plugin-syntax-export-default-from](https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from)\n \n #### 直接返回一个对象\n \n 这种方式的插件形式用于不需要处理参数的情况,这种我在官网还没有找到\n \n  ``` js\nexport default plugin = {\n  pre(state) {\n    this.cache = new Map();\n  },\n  visitor: {\n    StringLiteral(path, state) {\n      this.cache.set(path.node.value, 1);\n    },\n  },\n  post(state) {\n    console.log(this.cache);\n  },\n};\n  ```\n \n\n### visitor模式\n\n>visitor模式（访问者模式），作为设计模式的其中一种。访问者模式解决的是**数据**与**数据的操作方法**之间的耦合，将数据的操作方法独立于数据，使其可以自由演变。因此访问这更适合于那些**数据稳定**，但是数据的操作方法一遍的环境下。因此当操作方环境改变时，可以自由修改操作方法以适应操作环境，而不用修改原数据，实现操作方法的扩展。\n\n对应到 babel traverse 的实现，就是 AST(数据) 和 visitor（有很多操作方法） 分离，在 traverse（遍历）AST 的时候，调用注册的 visitor 来对其进行处理\n\n\n#### 路径（path）和作用域（scope）\n\n``` js\npath:NodePath\n```\n\n> babel AST 中只包含源码的一些信息，但是操作 AST 时要拿到父节点的信息，并且也需要对 AST 增删改的方法，这些都在 path 对象里。\n\n>scope 是作用域信息，javascript 中能生成作用域的就是模块、函数、块等，而且作用域之间会形成嵌套关系，也就是作用域链。babel 在遍历的过程中会生成作用域链保存在 path.scope 中。\n\n \n path api太强大， 要多用才熟悉\n \n\n## @babel/types\n\n[@babel/types](https://babeljs.io/docs/en/babel-types)\n\n\n## 总结\n\n大致了解怎么去写一个babel插件，在转成AST后，在transform阶段运用设计模式的访问者模式（数据和数据的操作方法解耦），然后通过path相关api去实现逻辑，path的类型是`NodePath`,这个里面包含了AST的path 和scope（作用域链），通过对api的各种操作，实现我们要的结果\n\n``` js\nvisitor: { \nExportNamedDeclaration(path) { \n  const { node, scope } = path;\n}\n```\n\n## 参考\n\n掘金小册[babel插件通关秘籍](https://juejin.cn/book/6946117847848321055/section/6946582521672892456)\n\n[babel-handbook](https://github.com/jamiebuilds/babel-handbook)","slug":"plugin","published":1,"updated":"2022-06-04T11:38:20.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3zvhuz10004kiwx12qmeary","content":"<p>举一个例子，以写一个自动生成API文档为主</p>\n<h2 id=\"plugin\"><a href=\"#plugin\" class=\"headerlink\" title=\"plugin\"></a>plugin</h2><h3 id=\"调用插件\"><a href=\"#调用插件\" class=\"headerlink\" title=\"调用插件\"></a>调用插件</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; transformFromAstSync &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;@babel/core&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span>  parser = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;@babel/parser&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> autoDocumentPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./plugin/auto-document-plugin&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> sourceCode = fs.<span class=\"title function_\">readFileSync</span>(path.<span class=\"title function_\">join</span>(__dirname, <span class=\"string\">&#x27;./sourceCode.ts&#x27;</span>), &#123;</span><br><span class=\"line\">    <span class=\"attr\">encoding</span>: <span class=\"string\">&#x27;utf-8&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转成AST</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ast = parser.<span class=\"title function_\">parse</span>(sourceCode, &#123;</span><br><span class=\"line\">    <span class=\"attr\">sourceType</span>: <span class=\"string\">&#x27;unambiguous&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [<span class=\"string\">&#x27;typescript&#x27;</span>]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插件使用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; code &#125; = <span class=\"title function_\">transformFromAstSync</span>(ast, sourceCode, &#123;</span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [[autoDocumentPlugin, &#123;</span><br><span class=\"line\">        <span class=\"attr\">outputDir</span>: path.<span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;./docs&#x27;</span>),</span><br><span class=\"line\">        <span class=\"attr\">format</span>: <span class=\"string\">&#x27;markdown&#x27;</span><span class=\"comment\">// html / json</span></span><br><span class=\"line\">    &#125;]]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"plugin模板\"><a href=\"#plugin模板\" class=\"headerlink\" title=\"plugin模板\"></a>plugin模板</h3><p>plugin 有两种形式</p>\n<h4 id=\"一个函数返回一个对象的格式\"><a href=\"#一个函数返回一个对象的格式\" class=\"headerlink\" title=\"一个函数返回一个对象的格式\"></a>一个函数返回一个对象的格式</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// xx-plugin.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; declare &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;@babel/helper-plugin-utils&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// api:  babel 的 api，</span></span><br><span class=\"line\"><span class=\"comment\">// options: 传给plugin的参数</span></span><br><span class=\"line\"><span class=\"comment\">// dirname： 目录名字</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> xxPlugin = <span class=\"title function_\">declare</span>(<span class=\"function\">(<span class=\"params\">api, options, dirname</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    api.<span class=\"title function_\">assertVersion</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> xxPlugin = <span class=\"title function_\">declare</span>(<span class=\"function\">(<span class=\"params\">api, options, dirname</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        api.<span class=\"title function_\">assertVersion</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">        <span class=\"comment\">// name 插件的名字</span></span><br><span class=\"line\">        <span class=\"comment\">// inherits 指定继承某个插件，和当前插件的 options 合并，通过 Object.assign 的方式。</span></span><br><span class=\"line\">        <span class=\"comment\">// pre 遍历前调用</span></span><br><span class=\"line\">        <span class=\"comment\">// visitor 指定 traverse 时调用的函数。</span></span><br><span class=\"line\">        <span class=\"comment\">// post 遍历后调用</span></span><br><span class=\"line\">        <span class=\"comment\">// manipulateOptions 用于修改 options，是在插件里面修改配置的方式，比如 babel-plugin-syntax-xx, 一般都会修改 parser options</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            <span class=\"attr\">name</span>: <span class=\"string\">&quot;proposal-export-namespace-from&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">inherits</span>: syntaxExportNamespaceFrom.<span class=\"property\">default</span>,</span><br><span class=\"line\">            <span class=\"title function_\">pre</span>(<span class=\"params\">file</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 代码逻辑</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">visitor</span>: &#123;</span><br><span class=\"line\">                <span class=\"title class_\">FunctionDeclaration</span>(path, state) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 代码逻辑</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"title function_\">manipulateOptions</span>(<span class=\"params\">opts, parserOpts</span>) &#123;   </span><br><span class=\"line\">                <span class=\"comment\">// 告诉 parser 要 parse xxx这个语法,如jsx </span></span><br><span class=\"line\">                 parserOpts.<span class=\"property\">plugins</span>.<span class=\"title function_\">push</span>(<span class=\"string\">&quot;xxx&quot;</span>);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"title function_\">post</span>(<span class=\"params\">file</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 代码逻辑</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p> 在babel官网找了几个插件的写法</p>\n<p> <a href=\"https://github.com/babel/babel/blob/main/packages/babel-plugin-proposal-export-default-from/src/index.ts\">babel-plugin-proposal-export-default-from</a></p>\n<p> <a href=\"https://github.com/babel/babel/blob/main/packages/babel-plugin-proposal-function-bind/src/index.ts\">babel-plugin-proposal-function-bind</a></p>\n<p> <a href=\"https://github.com/babel/babel/blob/main/packages/babel-plugin-proposal-numeric-separator/src/index.ts\">babel-plugin-proposal-numeric-separator</a></p>\n<p> <a href=\"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from\">babel-plugin-syntax-export-default-from</a></p>\n<h4 id=\"直接返回一个对象\"><a href=\"#直接返回一个对象\" class=\"headerlink\" title=\"直接返回一个对象\"></a>直接返回一个对象</h4><p> 这种方式的插件形式用于不需要处理参数的情况,这种我在官网还没有找到</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> plugin = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">pre</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">cache</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">visitor</span>: &#123;</span><br><span class=\"line\">    <span class=\"title class_\">StringLiteral</span>(path, state) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">cache</span>.<span class=\"title function_\">set</span>(path.<span class=\"property\">node</span>.<span class=\"property\">value</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"title function_\">post</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">cache</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"visitor模式\"><a href=\"#visitor模式\" class=\"headerlink\" title=\"visitor模式\"></a>visitor模式</h3><blockquote>\n<p>visitor模式（访问者模式），作为设计模式的其中一种。访问者模式解决的是<strong>数据</strong>与<strong>数据的操作方法</strong>之间的耦合，将数据的操作方法独立于数据，使其可以自由演变。因此访问这更适合于那些<strong>数据稳定</strong>，但是数据的操作方法一遍的环境下。因此当操作方环境改变时，可以自由修改操作方法以适应操作环境，而不用修改原数据，实现操作方法的扩展。</p>\n</blockquote>\n<p>对应到 babel traverse 的实现，就是 AST(数据) 和 visitor（有很多操作方法） 分离，在 traverse（遍历）AST 的时候，调用注册的 visitor 来对其进行处理</p>\n<h4 id=\"路径（path）和作用域（scope）\"><a href=\"#路径（path）和作用域（scope）\" class=\"headerlink\" title=\"路径（path）和作用域（scope）\"></a>路径（path）和作用域（scope）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">path</span>:<span class=\"title class_\">NodePath</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>babel AST 中只包含源码的一些信息，但是操作 AST 时要拿到父节点的信息，并且也需要对 AST 增删改的方法，这些都在 path 对象里。</p>\n</blockquote>\n<blockquote>\n<p>scope 是作用域信息，javascript 中能生成作用域的就是模块、函数、块等，而且作用域之间会形成嵌套关系，也就是作用域链。babel 在遍历的过程中会生成作用域链保存在 path.scope 中。</p>\n</blockquote>\n<p> path api太强大， 要多用才熟悉</p>\n<h2 id=\"babel-x2F-types\"><a href=\"#babel-x2F-types\" class=\"headerlink\" title=\"@babel&#x2F;types\"></a>@babel&#x2F;types</h2><p><a href=\"https://babeljs.io/docs/en/babel-types\">@babel&#x2F;types</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>大致了解怎么去写一个babel插件，在转成AST后，在transform阶段运用设计模式的访问者模式（数据和数据的操作方法解耦），然后通过path相关api去实现逻辑，path的类型是<code>NodePath</code>,这个里面包含了AST的path 和scope（作用域链），通过对api的各种操作，实现我们要的结果</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">visitor</span>: &#123; </span><br><span class=\"line\"><span class=\"title class_\">ExportNamedDeclaration</span>(path) &#123; </span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; node, scope &#125; = path;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>掘金小册<a href=\"https://juejin.cn/book/6946117847848321055/section/6946582521672892456\">babel插件通关秘籍</a></p>\n<p><a href=\"https://github.com/jamiebuilds/babel-handbook\">babel-handbook</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>举一个例子，以写一个自动生成API文档为主</p>\n<h2 id=\"plugin\"><a href=\"#plugin\" class=\"headerlink\" title=\"plugin\"></a>plugin</h2><h3 id=\"调用插件\"><a href=\"#调用插件\" class=\"headerlink\" title=\"调用插件\"></a>调用插件</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; transformFromAstSync &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;@babel/core&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span>  parser = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;@babel/parser&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> autoDocumentPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./plugin/auto-document-plugin&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> sourceCode = fs.<span class=\"title function_\">readFileSync</span>(path.<span class=\"title function_\">join</span>(__dirname, <span class=\"string\">&#x27;./sourceCode.ts&#x27;</span>), &#123;</span><br><span class=\"line\">    <span class=\"attr\">encoding</span>: <span class=\"string\">&#x27;utf-8&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转成AST</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ast = parser.<span class=\"title function_\">parse</span>(sourceCode, &#123;</span><br><span class=\"line\">    <span class=\"attr\">sourceType</span>: <span class=\"string\">&#x27;unambiguous&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [<span class=\"string\">&#x27;typescript&#x27;</span>]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插件使用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; code &#125; = <span class=\"title function_\">transformFromAstSync</span>(ast, sourceCode, &#123;</span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [[autoDocumentPlugin, &#123;</span><br><span class=\"line\">        <span class=\"attr\">outputDir</span>: path.<span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;./docs&#x27;</span>),</span><br><span class=\"line\">        <span class=\"attr\">format</span>: <span class=\"string\">&#x27;markdown&#x27;</span><span class=\"comment\">// html / json</span></span><br><span class=\"line\">    &#125;]]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"plugin模板\"><a href=\"#plugin模板\" class=\"headerlink\" title=\"plugin模板\"></a>plugin模板</h3><p>plugin 有两种形式</p>\n<h4 id=\"一个函数返回一个对象的格式\"><a href=\"#一个函数返回一个对象的格式\" class=\"headerlink\" title=\"一个函数返回一个对象的格式\"></a>一个函数返回一个对象的格式</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// xx-plugin.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; declare &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;@babel/helper-plugin-utils&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// api:  babel 的 api，</span></span><br><span class=\"line\"><span class=\"comment\">// options: 传给plugin的参数</span></span><br><span class=\"line\"><span class=\"comment\">// dirname： 目录名字</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> xxPlugin = <span class=\"title function_\">declare</span>(<span class=\"function\">(<span class=\"params\">api, options, dirname</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    api.<span class=\"title function_\">assertVersion</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> xxPlugin = <span class=\"title function_\">declare</span>(<span class=\"function\">(<span class=\"params\">api, options, dirname</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        api.<span class=\"title function_\">assertVersion</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">        <span class=\"comment\">// name 插件的名字</span></span><br><span class=\"line\">        <span class=\"comment\">// inherits 指定继承某个插件，和当前插件的 options 合并，通过 Object.assign 的方式。</span></span><br><span class=\"line\">        <span class=\"comment\">// pre 遍历前调用</span></span><br><span class=\"line\">        <span class=\"comment\">// visitor 指定 traverse 时调用的函数。</span></span><br><span class=\"line\">        <span class=\"comment\">// post 遍历后调用</span></span><br><span class=\"line\">        <span class=\"comment\">// manipulateOptions 用于修改 options，是在插件里面修改配置的方式，比如 babel-plugin-syntax-xx, 一般都会修改 parser options</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            <span class=\"attr\">name</span>: <span class=\"string\">&quot;proposal-export-namespace-from&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">inherits</span>: syntaxExportNamespaceFrom.<span class=\"property\">default</span>,</span><br><span class=\"line\">            <span class=\"title function_\">pre</span>(<span class=\"params\">file</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 代码逻辑</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">visitor</span>: &#123;</span><br><span class=\"line\">                <span class=\"title class_\">FunctionDeclaration</span>(path, state) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 代码逻辑</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"title function_\">manipulateOptions</span>(<span class=\"params\">opts, parserOpts</span>) &#123;   </span><br><span class=\"line\">                <span class=\"comment\">// 告诉 parser 要 parse xxx这个语法,如jsx </span></span><br><span class=\"line\">                 parserOpts.<span class=\"property\">plugins</span>.<span class=\"title function_\">push</span>(<span class=\"string\">&quot;xxx&quot;</span>);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"title function_\">post</span>(<span class=\"params\">file</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 代码逻辑</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p> 在babel官网找了几个插件的写法</p>\n<p> <a href=\"https://github.com/babel/babel/blob/main/packages/babel-plugin-proposal-export-default-from/src/index.ts\">babel-plugin-proposal-export-default-from</a></p>\n<p> <a href=\"https://github.com/babel/babel/blob/main/packages/babel-plugin-proposal-function-bind/src/index.ts\">babel-plugin-proposal-function-bind</a></p>\n<p> <a href=\"https://github.com/babel/babel/blob/main/packages/babel-plugin-proposal-numeric-separator/src/index.ts\">babel-plugin-proposal-numeric-separator</a></p>\n<p> <a href=\"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from\">babel-plugin-syntax-export-default-from</a></p>\n<h4 id=\"直接返回一个对象\"><a href=\"#直接返回一个对象\" class=\"headerlink\" title=\"直接返回一个对象\"></a>直接返回一个对象</h4><p> 这种方式的插件形式用于不需要处理参数的情况,这种我在官网还没有找到</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> plugin = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">pre</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">cache</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">visitor</span>: &#123;</span><br><span class=\"line\">    <span class=\"title class_\">StringLiteral</span>(path, state) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">cache</span>.<span class=\"title function_\">set</span>(path.<span class=\"property\">node</span>.<span class=\"property\">value</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"title function_\">post</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">cache</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"visitor模式\"><a href=\"#visitor模式\" class=\"headerlink\" title=\"visitor模式\"></a>visitor模式</h3><blockquote>\n<p>visitor模式（访问者模式），作为设计模式的其中一种。访问者模式解决的是<strong>数据</strong>与<strong>数据的操作方法</strong>之间的耦合，将数据的操作方法独立于数据，使其可以自由演变。因此访问这更适合于那些<strong>数据稳定</strong>，但是数据的操作方法一遍的环境下。因此当操作方环境改变时，可以自由修改操作方法以适应操作环境，而不用修改原数据，实现操作方法的扩展。</p>\n</blockquote>\n<p>对应到 babel traverse 的实现，就是 AST(数据) 和 visitor（有很多操作方法） 分离，在 traverse（遍历）AST 的时候，调用注册的 visitor 来对其进行处理</p>\n<h4 id=\"路径（path）和作用域（scope）\"><a href=\"#路径（path）和作用域（scope）\" class=\"headerlink\" title=\"路径（path）和作用域（scope）\"></a>路径（path）和作用域（scope）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">path</span>:<span class=\"title class_\">NodePath</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>babel AST 中只包含源码的一些信息，但是操作 AST 时要拿到父节点的信息，并且也需要对 AST 增删改的方法，这些都在 path 对象里。</p>\n</blockquote>\n<blockquote>\n<p>scope 是作用域信息，javascript 中能生成作用域的就是模块、函数、块等，而且作用域之间会形成嵌套关系，也就是作用域链。babel 在遍历的过程中会生成作用域链保存在 path.scope 中。</p>\n</blockquote>\n<p> path api太强大， 要多用才熟悉</p>\n<h2 id=\"babel-x2F-types\"><a href=\"#babel-x2F-types\" class=\"headerlink\" title=\"@babel&#x2F;types\"></a>@babel&#x2F;types</h2><p><a href=\"https://babeljs.io/docs/en/babel-types\">@babel&#x2F;types</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>大致了解怎么去写一个babel插件，在转成AST后，在transform阶段运用设计模式的访问者模式（数据和数据的操作方法解耦），然后通过path相关api去实现逻辑，path的类型是<code>NodePath</code>,这个里面包含了AST的path 和scope（作用域链），通过对api的各种操作，实现我们要的结果</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">visitor</span>: &#123; </span><br><span class=\"line\"><span class=\"title class_\">ExportNamedDeclaration</span>(path) &#123; </span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; node, scope &#125; = path;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>掘金小册<a href=\"https://juejin.cn/book/6946117847848321055/section/6946582521672892456\">babel插件通关秘籍</a></p>\n<p><a href=\"https://github.com/jamiebuilds/babel-handbook\">babel-handbook</a></p>\n"},{"title":"react 18","date":"2022-06-04T10:12:15.000Z","_content":"\n## What is Concurrent React（并发渲染）\n\n并发模式进行可中断渲染\n\n查阅了一些资料\n\n其目的为了提升帮助React应用保持响应，并优雅地适应用户的设备功能和网络速度\n\n\n因为有了这个并发渲染，Suspense, transitions, and SSR都是充分`并发渲染`去构建的\n\n\n\n### 可重用的状态\n\n接下来的小版本可能会增加 `Offscreen`\n\n\n## New Feature: Automatic Batching\n\n```\nReactDOM.flushSync()\n```\n\n[https://github.com/reactwg/react-18/discussions/21](https://github.com/reactwg/react-18/discussions/21)\n\n\n\n这看起来很像是一个使用者不需要太关心的feature，因为react 18自动处理了。在使用timeouts、promises、natives event handler或者其他events的更新将以与React事件中的更新相同的方式进行批处理，嗯嗯...就是为了减少渲染次数\n\n懒得复制代码了，直接截图\n\n### 函数式组件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b54eae955e743e68642ee6cb9f2e3e0~tplv-k3u1fbpfcp-watermark.image?)\n\n\n最终只会渲染一次\n\n\n### Class组件\n\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a4d2731d84f4aa8a7a2ab0fdecb50d1~tplv-k3u1fbpfcp-watermark.image?)\n\n\n### 不想自动批处理\n\n``` js\nimport { flushSync } from 'react-dom'; // Note: react-dom, not react\n\nfunction handleClick() {\n  flushSync(() => {\n    setCounter(c => c + 1);\n  });\n  // React has updated the DOM by now\n  flushSync(() => {\n    setFlag(f => !f);\n  });\n  // React has updated the DOM by now\n}\n```\n\n官方不推荐介么做啦\n\n\n## New Feature Transitions\n\n## New  Features Suspense\n\nhttps://github.com/reactwg/react-18/discussions/37\n\n\n## New Client and Server Rendering APIs\n\n ### Client Rendering APIs\n|  | Before` | React 18 | \n| --- | --- | ---|\n|  Updates to Client Rendering APIs | ReactDOM.render | ReactDOM.createRoot | \n|  Unmount | unmountComponentAtNode | root.unmount | \n|   | | 移除了render的callback| \n| Server-side rendering  | hydrate| hydrateRoot| \n\n#### changed `ReactDOM.render` to `ReactDOM.createRoot`\n``` js\n\n// Before\nimport { render } from 'react-dom';\nconst container = document.getElementById('app');\nrender(<App tab=\"home\" />, container);\n\n// After\nimport { createRoot } from 'react-dom/client';\nconst container = document.getElementById('app');\nconst root = createRoot(container);\nroot.render(<App tab=\"home\" />);\n\n```\n\n#### changed `unmountComponentAtNode` to `root.unmount`\n\n\n``` js\n// Before\nunmountComponentAtNode(container);\n\n// After\nroot.unmount();\n```\n\n\n#### 移除了render的callback\n\n``` js\n// Before\nconst container = document.getElementById('app');\nReactDOM.render(<App tab=\"home\" />, container, () => {\n  console.log('rendered');\n});\n\n// After\nfunction AppWithCallbackAfterRender() {\n  useEffect(() => {\n    console.log('rendered');\n  });\n\n  return <App tab=\"home\" />\n}\n\nconst container = document.getElementById('app');\nconst root = ReactDOM.createRoot(container);\nroot.render(<AppWithCallbackAfterRender />);\n```\n\n\n移除的原因是因为\n\n> 因为它在使用 Suspense 时通常没有预期的结果\n\n\n尴尬这个`Suspense`只是听闻过，但是没有使用过\n\n\n#### SSR hydrate 替换为 hydrateRoot\n``` js\n// Before\nimport { hydrate } from 'react-dom';\nconst container = document.getElementById('app');\nhydrate(<App tab=\"home\" />, container);\n\n// After\nimport { hydrateRoot } from 'react-dom/client';\nconst container = document.getElementById('app');\nconst root = hydrateRoot(container, <App tab=\"home\" />);\n//  哈哈，这里可以用不createRoot\n```\n\n也没有用过\n\n ### Server Rendering APIs\n \nThe following APIs will continue working, but with limited support for Suspense\n\n-   [`renderToString()`](https://reactjs.org/docs/react-dom-server.html#rendertostring)（Limited）\n-   [`renderToStaticMarkup()`](https://reactjs.org/docs/react-dom-server.html#rendertostaticmarkup)（Limited）\n\n\nThese additional methods depend on a package (`stream`) that is **only available on the server**, and won’t work in the browser.\n\n-   [`renderToPipeableStream()`](https://reactjs.org/docs/react-dom-server.html#rendertopipeablestream) (New)\n-   [`renderToReadableStream()`](https://reactjs.org/docs/react-dom-server.html#rendertoreadablestream)(New)\n-   [`renderToNodeStream()`](https://reactjs.org/docs/react-dom-server.html#rendertonodestream) (Deprecated)\n-   [`renderToStaticNodeStream()`](https://reactjs.org/docs/react-dom-server.html#rendertostaticnodestream)(不变)\n\n介绍新的API\n\n#### renderToPipeableStream\n\nrenderToString>renderToPipeableStream\n\n#### renderToReadableStream\n\n\n## New Strict Mode Behaviors\n\n\n## 新的hooks\n\n- useTransition\n\n- startTransition\n\nhttps://github.com/reactwg/react-18/discussions/41\n\nhttps://github.com/reactwg/react-18/discussions/65\n\n- useDeferredValue\n\n有点类似于防抖的功能\n\n- useInsertionEffect\n\n- useId\n\n- useSyncExternalStore\n\n## 从另一个维度看这次更新\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19f6d1dde8d94da7b55b972cf035e006~tplv-k3u1fbpfcp-watermark.image?)\n\nhttps://github.com/reactwg/react-18/discussions/4\n\n\n[discussions](https://github.com/reactwg/react-18/discussions)真是个好东西，可以及时看到更新的知识点\n\n\n","source":"_posts/react-18.md","raw":"---\ntitle: react 18\ndate: 2022-06-04 18:12:15\ntags: react 18\n---\n\n## What is Concurrent React（并发渲染）\n\n并发模式进行可中断渲染\n\n查阅了一些资料\n\n其目的为了提升帮助React应用保持响应，并优雅地适应用户的设备功能和网络速度\n\n\n因为有了这个并发渲染，Suspense, transitions, and SSR都是充分`并发渲染`去构建的\n\n\n\n### 可重用的状态\n\n接下来的小版本可能会增加 `Offscreen`\n\n\n## New Feature: Automatic Batching\n\n```\nReactDOM.flushSync()\n```\n\n[https://github.com/reactwg/react-18/discussions/21](https://github.com/reactwg/react-18/discussions/21)\n\n\n\n这看起来很像是一个使用者不需要太关心的feature，因为react 18自动处理了。在使用timeouts、promises、natives event handler或者其他events的更新将以与React事件中的更新相同的方式进行批处理，嗯嗯...就是为了减少渲染次数\n\n懒得复制代码了，直接截图\n\n### 函数式组件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b54eae955e743e68642ee6cb9f2e3e0~tplv-k3u1fbpfcp-watermark.image?)\n\n\n最终只会渲染一次\n\n\n### Class组件\n\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a4d2731d84f4aa8a7a2ab0fdecb50d1~tplv-k3u1fbpfcp-watermark.image?)\n\n\n### 不想自动批处理\n\n``` js\nimport { flushSync } from 'react-dom'; // Note: react-dom, not react\n\nfunction handleClick() {\n  flushSync(() => {\n    setCounter(c => c + 1);\n  });\n  // React has updated the DOM by now\n  flushSync(() => {\n    setFlag(f => !f);\n  });\n  // React has updated the DOM by now\n}\n```\n\n官方不推荐介么做啦\n\n\n## New Feature Transitions\n\n## New  Features Suspense\n\nhttps://github.com/reactwg/react-18/discussions/37\n\n\n## New Client and Server Rendering APIs\n\n ### Client Rendering APIs\n|  | Before` | React 18 | \n| --- | --- | ---|\n|  Updates to Client Rendering APIs | ReactDOM.render | ReactDOM.createRoot | \n|  Unmount | unmountComponentAtNode | root.unmount | \n|   | | 移除了render的callback| \n| Server-side rendering  | hydrate| hydrateRoot| \n\n#### changed `ReactDOM.render` to `ReactDOM.createRoot`\n``` js\n\n// Before\nimport { render } from 'react-dom';\nconst container = document.getElementById('app');\nrender(<App tab=\"home\" />, container);\n\n// After\nimport { createRoot } from 'react-dom/client';\nconst container = document.getElementById('app');\nconst root = createRoot(container);\nroot.render(<App tab=\"home\" />);\n\n```\n\n#### changed `unmountComponentAtNode` to `root.unmount`\n\n\n``` js\n// Before\nunmountComponentAtNode(container);\n\n// After\nroot.unmount();\n```\n\n\n#### 移除了render的callback\n\n``` js\n// Before\nconst container = document.getElementById('app');\nReactDOM.render(<App tab=\"home\" />, container, () => {\n  console.log('rendered');\n});\n\n// After\nfunction AppWithCallbackAfterRender() {\n  useEffect(() => {\n    console.log('rendered');\n  });\n\n  return <App tab=\"home\" />\n}\n\nconst container = document.getElementById('app');\nconst root = ReactDOM.createRoot(container);\nroot.render(<AppWithCallbackAfterRender />);\n```\n\n\n移除的原因是因为\n\n> 因为它在使用 Suspense 时通常没有预期的结果\n\n\n尴尬这个`Suspense`只是听闻过，但是没有使用过\n\n\n#### SSR hydrate 替换为 hydrateRoot\n``` js\n// Before\nimport { hydrate } from 'react-dom';\nconst container = document.getElementById('app');\nhydrate(<App tab=\"home\" />, container);\n\n// After\nimport { hydrateRoot } from 'react-dom/client';\nconst container = document.getElementById('app');\nconst root = hydrateRoot(container, <App tab=\"home\" />);\n//  哈哈，这里可以用不createRoot\n```\n\n也没有用过\n\n ### Server Rendering APIs\n \nThe following APIs will continue working, but with limited support for Suspense\n\n-   [`renderToString()`](https://reactjs.org/docs/react-dom-server.html#rendertostring)（Limited）\n-   [`renderToStaticMarkup()`](https://reactjs.org/docs/react-dom-server.html#rendertostaticmarkup)（Limited）\n\n\nThese additional methods depend on a package (`stream`) that is **only available on the server**, and won’t work in the browser.\n\n-   [`renderToPipeableStream()`](https://reactjs.org/docs/react-dom-server.html#rendertopipeablestream) (New)\n-   [`renderToReadableStream()`](https://reactjs.org/docs/react-dom-server.html#rendertoreadablestream)(New)\n-   [`renderToNodeStream()`](https://reactjs.org/docs/react-dom-server.html#rendertonodestream) (Deprecated)\n-   [`renderToStaticNodeStream()`](https://reactjs.org/docs/react-dom-server.html#rendertostaticnodestream)(不变)\n\n介绍新的API\n\n#### renderToPipeableStream\n\nrenderToString>renderToPipeableStream\n\n#### renderToReadableStream\n\n\n## New Strict Mode Behaviors\n\n\n## 新的hooks\n\n- useTransition\n\n- startTransition\n\nhttps://github.com/reactwg/react-18/discussions/41\n\nhttps://github.com/reactwg/react-18/discussions/65\n\n- useDeferredValue\n\n有点类似于防抖的功能\n\n- useInsertionEffect\n\n- useId\n\n- useSyncExternalStore\n\n## 从另一个维度看这次更新\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19f6d1dde8d94da7b55b972cf035e006~tplv-k3u1fbpfcp-watermark.image?)\n\nhttps://github.com/reactwg/react-18/discussions/4\n\n\n[discussions](https://github.com/reactwg/react-18/discussions)真是个好东西，可以及时看到更新的知识点\n\n\n","slug":"react-18","published":1,"updated":"2022-06-04T11:38:20.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3zvhuz20005kiwxeehpbipp","content":"<h2 id=\"What-is-Concurrent-React（并发渲染）\"><a href=\"#What-is-Concurrent-React（并发渲染）\" class=\"headerlink\" title=\"What is Concurrent React（并发渲染）\"></a>What is Concurrent React（并发渲染）</h2><p>并发模式进行可中断渲染</p>\n<p>查阅了一些资料</p>\n<p>其目的为了提升帮助React应用保持响应，并优雅地适应用户的设备功能和网络速度</p>\n<p>因为有了这个并发渲染，Suspense, transitions, and SSR都是充分<code>并发渲染</code>去构建的</p>\n<h3 id=\"可重用的状态\"><a href=\"#可重用的状态\" class=\"headerlink\" title=\"可重用的状态\"></a>可重用的状态</h3><p>接下来的小版本可能会增加 <code>Offscreen</code></p>\n<h2 id=\"New-Feature-Automatic-Batching\"><a href=\"#New-Feature-Automatic-Batching\" class=\"headerlink\" title=\"New Feature: Automatic Batching\"></a>New Feature: Automatic Batching</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.flushSync()</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/reactwg/react-18/discussions/21\">https://github.com/reactwg/react-18/discussions/21</a></p>\n<p>这看起来很像是一个使用者不需要太关心的feature，因为react 18自动处理了。在使用timeouts、promises、natives event handler或者其他events的更新将以与React事件中的更新相同的方式进行批处理，嗯嗯…就是为了减少渲染次数</p>\n<p>懒得复制代码了，直接截图</p>\n<h3 id=\"函数式组件\"><a href=\"#函数式组件\" class=\"headerlink\" title=\"函数式组件\"></a>函数式组件</h3><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b54eae955e743e68642ee6cb9f2e3e0~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>最终只会渲染一次</p>\n<h3 id=\"Class组件\"><a href=\"#Class组件\" class=\"headerlink\" title=\"Class组件\"></a>Class组件</h3><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a4d2731d84f4aa8a7a2ab0fdecb50d1~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3 id=\"不想自动批处理\"><a href=\"#不想自动批处理\" class=\"headerlink\" title=\"不想自动批处理\"></a>不想自动批处理</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; flushSync &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-dom&#x27;</span>; <span class=\"comment\">// Note: react-dom, not react</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleClick</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">flushSync</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setCounter</span>(<span class=\"function\"><span class=\"params\">c</span> =&gt;</span> c + <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// React has updated the DOM by now</span></span><br><span class=\"line\">  <span class=\"title function_\">flushSync</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setFlag</span>(<span class=\"function\"><span class=\"params\">f</span> =&gt;</span> !f);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// React has updated the DOM by now</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>官方不推荐介么做啦</p>\n<h2 id=\"New-Feature-Transitions\"><a href=\"#New-Feature-Transitions\" class=\"headerlink\" title=\"New Feature Transitions\"></a>New Feature Transitions</h2><h2 id=\"New-Features-Suspense\"><a href=\"#New-Features-Suspense\" class=\"headerlink\" title=\"New  Features Suspense\"></a>New  Features Suspense</h2><p><a href=\"https://github.com/reactwg/react-18/discussions/37\">https://github.com/reactwg/react-18/discussions/37</a></p>\n<h2 id=\"New-Client-and-Server-Rendering-APIs\"><a href=\"#New-Client-and-Server-Rendering-APIs\" class=\"headerlink\" title=\"New Client and Server Rendering APIs\"></a>New Client and Server Rendering APIs</h2><h3 id=\"Client-Rendering-APIs\"><a href=\"#Client-Rendering-APIs\" class=\"headerlink\" title=\"Client Rendering APIs\"></a>Client Rendering APIs</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>Before&#96;</th>\n<th>React 18</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Updates to Client Rendering APIs</td>\n<td>ReactDOM.render</td>\n<td>ReactDOM.createRoot</td>\n</tr>\n<tr>\n<td>Unmount</td>\n<td>unmountComponentAtNode</td>\n<td>root.unmount</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>移除了render的callback</td>\n</tr>\n<tr>\n<td>Server-side rendering</td>\n<td>hydrate</td>\n<td>hydrateRoot</td>\n</tr>\n</tbody></table>\n<h4 id=\"changed-ReactDOM-render-to-ReactDOM-createRoot\"><a href=\"#changed-ReactDOM-render-to-ReactDOM-createRoot\" class=\"headerlink\" title=\"changed ReactDOM.render to ReactDOM.createRoot\"></a>changed <code>ReactDOM.render</code> to <code>ReactDOM.createRoot</code></h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Before</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; render &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-dom&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>);</span><br><span class=\"line\"><span class=\"title function_\">render</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">tab</span>=<span class=\"string\">&quot;home&quot;</span> /&gt;</span></span>, container);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createRoot &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-dom/client&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"title function_\">createRoot</span>(container);</span><br><span class=\"line\">root.<span class=\"title function_\">render</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">tab</span>=<span class=\"string\">&quot;home&quot;</span> /&gt;</span></span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"changed-unmountComponentAtNode-to-root-unmount\"><a href=\"#changed-unmountComponentAtNode-to-root-unmount\" class=\"headerlink\" title=\"changed unmountComponentAtNode to root.unmount\"></a>changed <code>unmountComponentAtNode</code> to <code>root.unmount</code></h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Before</span></span><br><span class=\"line\"><span class=\"title function_\">unmountComponentAtNode</span>(container);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After</span></span><br><span class=\"line\">root.<span class=\"title function_\">unmount</span>();</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"移除了render的callback\"><a href=\"#移除了render的callback\" class=\"headerlink\" title=\"移除了render的callback\"></a>移除了render的callback</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Before</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>);</span><br><span class=\"line\"><span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">tab</span>=<span class=\"string\">&quot;home&quot;</span> /&gt;</span></span>, container, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;rendered&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">AppWithCallbackAfterRender</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;rendered&#x27;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">tab</span>=<span class=\"string\">&quot;home&quot;</span> /&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">createRoot</span>(container);</span><br><span class=\"line\">root.<span class=\"title function_\">render</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">AppWithCallbackAfterRender</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>\n\n\n<p>移除的原因是因为</p>\n<blockquote>\n<p>因为它在使用 Suspense 时通常没有预期的结果</p>\n</blockquote>\n<p>尴尬这个<code>Suspense</code>只是听闻过，但是没有使用过</p>\n<h4 id=\"SSR-hydrate-替换为-hydrateRoot\"><a href=\"#SSR-hydrate-替换为-hydrateRoot\" class=\"headerlink\" title=\"SSR hydrate 替换为 hydrateRoot\"></a>SSR hydrate 替换为 hydrateRoot</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Before</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; hydrate &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-dom&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>);</span><br><span class=\"line\"><span class=\"title function_\">hydrate</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">tab</span>=<span class=\"string\">&quot;home&quot;</span> /&gt;</span></span>, container);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; hydrateRoot &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-dom/client&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"title function_\">hydrateRoot</span>(container, <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">tab</span>=<span class=\"string\">&quot;home&quot;</span> /&gt;</span></span>);</span><br><span class=\"line\"><span class=\"comment\">//  哈哈，这里可以用不createRoot</span></span><br></pre></td></tr></table></figure>\n\n<p>也没有用过</p>\n<h3 id=\"Server-Rendering-APIs\"><a href=\"#Server-Rendering-APIs\" class=\"headerlink\" title=\"Server Rendering APIs\"></a>Server Rendering APIs</h3><p>The following APIs will continue working, but with limited support for Suspense</p>\n<ul>\n<li><a href=\"https://reactjs.org/docs/react-dom-server.html#rendertostring\"><code>renderToString()</code></a>（Limited）</li>\n<li><a href=\"https://reactjs.org/docs/react-dom-server.html#rendertostaticmarkup\"><code>renderToStaticMarkup()</code></a>（Limited）</li>\n</ul>\n<p>These additional methods depend on a package (<code>stream</code>) that is <strong>only available on the server</strong>, and won’t work in the browser.</p>\n<ul>\n<li><a href=\"https://reactjs.org/docs/react-dom-server.html#rendertopipeablestream\"><code>renderToPipeableStream()</code></a> (New)</li>\n<li><a href=\"https://reactjs.org/docs/react-dom-server.html#rendertoreadablestream\"><code>renderToReadableStream()</code></a>(New)</li>\n<li><a href=\"https://reactjs.org/docs/react-dom-server.html#rendertonodestream\"><code>renderToNodeStream()</code></a> (Deprecated)</li>\n<li><a href=\"https://reactjs.org/docs/react-dom-server.html#rendertostaticnodestream\"><code>renderToStaticNodeStream()</code></a>(不变)</li>\n</ul>\n<p>介绍新的API</p>\n<h4 id=\"renderToPipeableStream\"><a href=\"#renderToPipeableStream\" class=\"headerlink\" title=\"renderToPipeableStream\"></a>renderToPipeableStream</h4><p>renderToString&gt;renderToPipeableStream</p>\n<h4 id=\"renderToReadableStream\"><a href=\"#renderToReadableStream\" class=\"headerlink\" title=\"renderToReadableStream\"></a>renderToReadableStream</h4><h2 id=\"New-Strict-Mode-Behaviors\"><a href=\"#New-Strict-Mode-Behaviors\" class=\"headerlink\" title=\"New Strict Mode Behaviors\"></a>New Strict Mode Behaviors</h2><h2 id=\"新的hooks\"><a href=\"#新的hooks\" class=\"headerlink\" title=\"新的hooks\"></a>新的hooks</h2><ul>\n<li><p>useTransition</p>\n</li>\n<li><p>startTransition</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/reactwg/react-18/discussions/41\">https://github.com/reactwg/react-18/discussions/41</a></p>\n<p><a href=\"https://github.com/reactwg/react-18/discussions/65\">https://github.com/reactwg/react-18/discussions/65</a></p>\n<ul>\n<li>useDeferredValue</li>\n</ul>\n<p>有点类似于防抖的功能</p>\n<ul>\n<li><p>useInsertionEffect</p>\n</li>\n<li><p>useId</p>\n</li>\n<li><p>useSyncExternalStore</p>\n</li>\n</ul>\n<h2 id=\"从另一个维度看这次更新\"><a href=\"#从另一个维度看这次更新\" class=\"headerlink\" title=\"从另一个维度看这次更新\"></a>从另一个维度看这次更新</h2><p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19f6d1dde8d94da7b55b972cf035e006~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p><a href=\"https://github.com/reactwg/react-18/discussions/4\">https://github.com/reactwg/react-18/discussions/4</a></p>\n<p><a href=\"https://github.com/reactwg/react-18/discussions\">discussions</a>真是个好东西，可以及时看到更新的知识点</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"What-is-Concurrent-React（并发渲染）\"><a href=\"#What-is-Concurrent-React（并发渲染）\" class=\"headerlink\" title=\"What is Concurrent React（并发渲染）\"></a>What is Concurrent React（并发渲染）</h2><p>并发模式进行可中断渲染</p>\n<p>查阅了一些资料</p>\n<p>其目的为了提升帮助React应用保持响应，并优雅地适应用户的设备功能和网络速度</p>\n<p>因为有了这个并发渲染，Suspense, transitions, and SSR都是充分<code>并发渲染</code>去构建的</p>\n<h3 id=\"可重用的状态\"><a href=\"#可重用的状态\" class=\"headerlink\" title=\"可重用的状态\"></a>可重用的状态</h3><p>接下来的小版本可能会增加 <code>Offscreen</code></p>\n<h2 id=\"New-Feature-Automatic-Batching\"><a href=\"#New-Feature-Automatic-Batching\" class=\"headerlink\" title=\"New Feature: Automatic Batching\"></a>New Feature: Automatic Batching</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.flushSync()</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/reactwg/react-18/discussions/21\">https://github.com/reactwg/react-18/discussions/21</a></p>\n<p>这看起来很像是一个使用者不需要太关心的feature，因为react 18自动处理了。在使用timeouts、promises、natives event handler或者其他events的更新将以与React事件中的更新相同的方式进行批处理，嗯嗯…就是为了减少渲染次数</p>\n<p>懒得复制代码了，直接截图</p>\n<h3 id=\"函数式组件\"><a href=\"#函数式组件\" class=\"headerlink\" title=\"函数式组件\"></a>函数式组件</h3><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b54eae955e743e68642ee6cb9f2e3e0~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>最终只会渲染一次</p>\n<h3 id=\"Class组件\"><a href=\"#Class组件\" class=\"headerlink\" title=\"Class组件\"></a>Class组件</h3><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a4d2731d84f4aa8a7a2ab0fdecb50d1~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3 id=\"不想自动批处理\"><a href=\"#不想自动批处理\" class=\"headerlink\" title=\"不想自动批处理\"></a>不想自动批处理</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; flushSync &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-dom&#x27;</span>; <span class=\"comment\">// Note: react-dom, not react</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleClick</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">flushSync</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setCounter</span>(<span class=\"function\"><span class=\"params\">c</span> =&gt;</span> c + <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// React has updated the DOM by now</span></span><br><span class=\"line\">  <span class=\"title function_\">flushSync</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setFlag</span>(<span class=\"function\"><span class=\"params\">f</span> =&gt;</span> !f);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// React has updated the DOM by now</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>官方不推荐介么做啦</p>\n<h2 id=\"New-Feature-Transitions\"><a href=\"#New-Feature-Transitions\" class=\"headerlink\" title=\"New Feature Transitions\"></a>New Feature Transitions</h2><h2 id=\"New-Features-Suspense\"><a href=\"#New-Features-Suspense\" class=\"headerlink\" title=\"New  Features Suspense\"></a>New  Features Suspense</h2><p><a href=\"https://github.com/reactwg/react-18/discussions/37\">https://github.com/reactwg/react-18/discussions/37</a></p>\n<h2 id=\"New-Client-and-Server-Rendering-APIs\"><a href=\"#New-Client-and-Server-Rendering-APIs\" class=\"headerlink\" title=\"New Client and Server Rendering APIs\"></a>New Client and Server Rendering APIs</h2><h3 id=\"Client-Rendering-APIs\"><a href=\"#Client-Rendering-APIs\" class=\"headerlink\" title=\"Client Rendering APIs\"></a>Client Rendering APIs</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>Before&#96;</th>\n<th>React 18</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Updates to Client Rendering APIs</td>\n<td>ReactDOM.render</td>\n<td>ReactDOM.createRoot</td>\n</tr>\n<tr>\n<td>Unmount</td>\n<td>unmountComponentAtNode</td>\n<td>root.unmount</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>移除了render的callback</td>\n</tr>\n<tr>\n<td>Server-side rendering</td>\n<td>hydrate</td>\n<td>hydrateRoot</td>\n</tr>\n</tbody></table>\n<h4 id=\"changed-ReactDOM-render-to-ReactDOM-createRoot\"><a href=\"#changed-ReactDOM-render-to-ReactDOM-createRoot\" class=\"headerlink\" title=\"changed ReactDOM.render to ReactDOM.createRoot\"></a>changed <code>ReactDOM.render</code> to <code>ReactDOM.createRoot</code></h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Before</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; render &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-dom&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>);</span><br><span class=\"line\"><span class=\"title function_\">render</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">tab</span>=<span class=\"string\">&quot;home&quot;</span> /&gt;</span></span>, container);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createRoot &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-dom/client&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"title function_\">createRoot</span>(container);</span><br><span class=\"line\">root.<span class=\"title function_\">render</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">tab</span>=<span class=\"string\">&quot;home&quot;</span> /&gt;</span></span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"changed-unmountComponentAtNode-to-root-unmount\"><a href=\"#changed-unmountComponentAtNode-to-root-unmount\" class=\"headerlink\" title=\"changed unmountComponentAtNode to root.unmount\"></a>changed <code>unmountComponentAtNode</code> to <code>root.unmount</code></h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Before</span></span><br><span class=\"line\"><span class=\"title function_\">unmountComponentAtNode</span>(container);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After</span></span><br><span class=\"line\">root.<span class=\"title function_\">unmount</span>();</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"移除了render的callback\"><a href=\"#移除了render的callback\" class=\"headerlink\" title=\"移除了render的callback\"></a>移除了render的callback</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Before</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>);</span><br><span class=\"line\"><span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">tab</span>=<span class=\"string\">&quot;home&quot;</span> /&gt;</span></span>, container, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;rendered&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">AppWithCallbackAfterRender</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;rendered&#x27;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">tab</span>=<span class=\"string\">&quot;home&quot;</span> /&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">createRoot</span>(container);</span><br><span class=\"line\">root.<span class=\"title function_\">render</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">AppWithCallbackAfterRender</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>\n\n\n<p>移除的原因是因为</p>\n<blockquote>\n<p>因为它在使用 Suspense 时通常没有预期的结果</p>\n</blockquote>\n<p>尴尬这个<code>Suspense</code>只是听闻过，但是没有使用过</p>\n<h4 id=\"SSR-hydrate-替换为-hydrateRoot\"><a href=\"#SSR-hydrate-替换为-hydrateRoot\" class=\"headerlink\" title=\"SSR hydrate 替换为 hydrateRoot\"></a>SSR hydrate 替换为 hydrateRoot</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Before</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; hydrate &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-dom&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>);</span><br><span class=\"line\"><span class=\"title function_\">hydrate</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">tab</span>=<span class=\"string\">&quot;home&quot;</span> /&gt;</span></span>, container);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; hydrateRoot &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-dom/client&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"title function_\">hydrateRoot</span>(container, <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">tab</span>=<span class=\"string\">&quot;home&quot;</span> /&gt;</span></span>);</span><br><span class=\"line\"><span class=\"comment\">//  哈哈，这里可以用不createRoot</span></span><br></pre></td></tr></table></figure>\n\n<p>也没有用过</p>\n<h3 id=\"Server-Rendering-APIs\"><a href=\"#Server-Rendering-APIs\" class=\"headerlink\" title=\"Server Rendering APIs\"></a>Server Rendering APIs</h3><p>The following APIs will continue working, but with limited support for Suspense</p>\n<ul>\n<li><a href=\"https://reactjs.org/docs/react-dom-server.html#rendertostring\"><code>renderToString()</code></a>（Limited）</li>\n<li><a href=\"https://reactjs.org/docs/react-dom-server.html#rendertostaticmarkup\"><code>renderToStaticMarkup()</code></a>（Limited）</li>\n</ul>\n<p>These additional methods depend on a package (<code>stream</code>) that is <strong>only available on the server</strong>, and won’t work in the browser.</p>\n<ul>\n<li><a href=\"https://reactjs.org/docs/react-dom-server.html#rendertopipeablestream\"><code>renderToPipeableStream()</code></a> (New)</li>\n<li><a href=\"https://reactjs.org/docs/react-dom-server.html#rendertoreadablestream\"><code>renderToReadableStream()</code></a>(New)</li>\n<li><a href=\"https://reactjs.org/docs/react-dom-server.html#rendertonodestream\"><code>renderToNodeStream()</code></a> (Deprecated)</li>\n<li><a href=\"https://reactjs.org/docs/react-dom-server.html#rendertostaticnodestream\"><code>renderToStaticNodeStream()</code></a>(不变)</li>\n</ul>\n<p>介绍新的API</p>\n<h4 id=\"renderToPipeableStream\"><a href=\"#renderToPipeableStream\" class=\"headerlink\" title=\"renderToPipeableStream\"></a>renderToPipeableStream</h4><p>renderToString&gt;renderToPipeableStream</p>\n<h4 id=\"renderToReadableStream\"><a href=\"#renderToReadableStream\" class=\"headerlink\" title=\"renderToReadableStream\"></a>renderToReadableStream</h4><h2 id=\"New-Strict-Mode-Behaviors\"><a href=\"#New-Strict-Mode-Behaviors\" class=\"headerlink\" title=\"New Strict Mode Behaviors\"></a>New Strict Mode Behaviors</h2><h2 id=\"新的hooks\"><a href=\"#新的hooks\" class=\"headerlink\" title=\"新的hooks\"></a>新的hooks</h2><ul>\n<li><p>useTransition</p>\n</li>\n<li><p>startTransition</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/reactwg/react-18/discussions/41\">https://github.com/reactwg/react-18/discussions/41</a></p>\n<p><a href=\"https://github.com/reactwg/react-18/discussions/65\">https://github.com/reactwg/react-18/discussions/65</a></p>\n<ul>\n<li>useDeferredValue</li>\n</ul>\n<p>有点类似于防抖的功能</p>\n<ul>\n<li><p>useInsertionEffect</p>\n</li>\n<li><p>useId</p>\n</li>\n<li><p>useSyncExternalStore</p>\n</li>\n</ul>\n<h2 id=\"从另一个维度看这次更新\"><a href=\"#从另一个维度看这次更新\" class=\"headerlink\" title=\"从另一个维度看这次更新\"></a>从另一个维度看这次更新</h2><p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19f6d1dde8d94da7b55b972cf035e006~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p><a href=\"https://github.com/reactwg/react-18/discussions/4\">https://github.com/reactwg/react-18/discussions/4</a></p>\n<p><a href=\"https://github.com/reactwg/react-18/discussions\">discussions</a>真是个好东西，可以及时看到更新的知识点</p>\n"},{"title":"依赖版本锁不锁","date":"2022-06-04T03:34:22.000Z","_content":"\n原文链接：[依赖版本锁不锁](https://wx.zsxq.com/dweb2/index/topic_detail/185452122241212)\n\n本来只是看下依赖预打包是怎么回事，然后被迫又重新读了这篇文章。有几点值得思考的\n\n## 关于依赖版本到底锁不锁，锁？如何保持更新，不锁？如何保持稳定\n\n *中间商锁依赖，定期更新，并对此负责*\n\n1、 依赖分为node依赖和browser依赖，其实我一直区分不了这两者。后者考虑tree-sharking、产物尺寸等\n\n2、 依赖从一个维度分为间接依赖和直接依赖，锁直接依赖只能解决部分问题\n\n3、目前社区已有的解决方案\n\n1）cnpm提供的bug-versions\n\n2）npm提供的resolutions\n\n3) 侵入式代码patch-package\n\n\n[patch-package](https://www.npmjs.com/package/patch-package)，这个点学到了。因为我在实际工作中也碰到过，之前是forked的或者拷贝源码到本地，如今学到这一招`patch-package`。\n\n以下翻译自[patch-package](https://www.npmjs.com/package/patch-package)\n\n## patch-package\n\n### Patch 相比 forked，好处在于\n\n-  有时forked是需要额外的构建步骤\n\n-  当依赖发生变化的时候，会告诉你一个红色的提示，让你检查你的修复是否依然有效\n\n-  将你的补丁与依赖它们的代码放在一起。\n\n-  patches 可以是正常review过程中的一部分，但是forked 不会\n\n\n### 什么时候使用forked\n\n- 变化太大了无法原地开发\n\n- 这种变化对他人有用\n\n- 你可以创建一个合适的pr\n\n### Patch 有危险吗\n\n不会.有几个点必须要记住\n\n- 在有没有patch文件的分支切换时，很容易忘记运行`yarn` or `npm`\n\n- 如果长期的补丁影响到一个定期更新的代码区域，而你也想定期更新软件包，那么维护的成本就会很高。\n\n- 大的semantic变化很难review，让它们小而且明显，或者添加注释\n\n- 改变也会影响其他未触及的软件包的行为。通常情况下，这种情况会很明显，而且往往是希望如此，但还是要小心。（这句翻译好生硬，西巴）\n\n\n\n## umi本身自己是怎么解决的\n\n>背后主要是uⅱ层对依赖做了彻底锁，包含间接依赖，通过预打包依赖的方式，就算再过10年，也不会出现因node依赖更新导致umi挂的情况。此外还有些细节，比如babel runtime和polyfill等browser依赖的锁定等。\n\n ###能套用到browser吗？\n\n不能。因为预打包会让tree-shaking失效。node库大部分能在流程中发现，但是browser库必须要到线上才能发现。\n\n> 所以importmaps锁+有人担保的类xx-antd中间依赖+灰度可能是browser依赖的完美解。至于为什么procode为啥直接用x-antd不完美？因为间接依赖没锁。\n\n哎，学习学着学着就发散了\n","source":"_posts/依赖版本锁不锁.md","raw":"---\ntitle: 依赖版本锁不锁\ndate: 2022-06-04 11:34:22\ntags:\n---\n\n原文链接：[依赖版本锁不锁](https://wx.zsxq.com/dweb2/index/topic_detail/185452122241212)\n\n本来只是看下依赖预打包是怎么回事，然后被迫又重新读了这篇文章。有几点值得思考的\n\n## 关于依赖版本到底锁不锁，锁？如何保持更新，不锁？如何保持稳定\n\n *中间商锁依赖，定期更新，并对此负责*\n\n1、 依赖分为node依赖和browser依赖，其实我一直区分不了这两者。后者考虑tree-sharking、产物尺寸等\n\n2、 依赖从一个维度分为间接依赖和直接依赖，锁直接依赖只能解决部分问题\n\n3、目前社区已有的解决方案\n\n1）cnpm提供的bug-versions\n\n2）npm提供的resolutions\n\n3) 侵入式代码patch-package\n\n\n[patch-package](https://www.npmjs.com/package/patch-package)，这个点学到了。因为我在实际工作中也碰到过，之前是forked的或者拷贝源码到本地，如今学到这一招`patch-package`。\n\n以下翻译自[patch-package](https://www.npmjs.com/package/patch-package)\n\n## patch-package\n\n### Patch 相比 forked，好处在于\n\n-  有时forked是需要额外的构建步骤\n\n-  当依赖发生变化的时候，会告诉你一个红色的提示，让你检查你的修复是否依然有效\n\n-  将你的补丁与依赖它们的代码放在一起。\n\n-  patches 可以是正常review过程中的一部分，但是forked 不会\n\n\n### 什么时候使用forked\n\n- 变化太大了无法原地开发\n\n- 这种变化对他人有用\n\n- 你可以创建一个合适的pr\n\n### Patch 有危险吗\n\n不会.有几个点必须要记住\n\n- 在有没有patch文件的分支切换时，很容易忘记运行`yarn` or `npm`\n\n- 如果长期的补丁影响到一个定期更新的代码区域，而你也想定期更新软件包，那么维护的成本就会很高。\n\n- 大的semantic变化很难review，让它们小而且明显，或者添加注释\n\n- 改变也会影响其他未触及的软件包的行为。通常情况下，这种情况会很明显，而且往往是希望如此，但还是要小心。（这句翻译好生硬，西巴）\n\n\n\n## umi本身自己是怎么解决的\n\n>背后主要是uⅱ层对依赖做了彻底锁，包含间接依赖，通过预打包依赖的方式，就算再过10年，也不会出现因node依赖更新导致umi挂的情况。此外还有些细节，比如babel runtime和polyfill等browser依赖的锁定等。\n\n ###能套用到browser吗？\n\n不能。因为预打包会让tree-shaking失效。node库大部分能在流程中发现，但是browser库必须要到线上才能发现。\n\n> 所以importmaps锁+有人担保的类xx-antd中间依赖+灰度可能是browser依赖的完美解。至于为什么procode为啥直接用x-antd不完美？因为间接依赖没锁。\n\n哎，学习学着学着就发散了\n","slug":"依赖版本锁不锁","published":1,"updated":"2022-06-04T11:38:20.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3zvhuz30008kiwxaecz4hc1","content":"<p>原文链接：<a href=\"https://wx.zsxq.com/dweb2/index/topic_detail/185452122241212\">依赖版本锁不锁</a></p>\n<p>本来只是看下依赖预打包是怎么回事，然后被迫又重新读了这篇文章。有几点值得思考的</p>\n<h2 id=\"关于依赖版本到底锁不锁，锁？如何保持更新，不锁？如何保持稳定\"><a href=\"#关于依赖版本到底锁不锁，锁？如何保持更新，不锁？如何保持稳定\" class=\"headerlink\" title=\"关于依赖版本到底锁不锁，锁？如何保持更新，不锁？如何保持稳定\"></a>关于依赖版本到底锁不锁，锁？如何保持更新，不锁？如何保持稳定</h2><p> <em>中间商锁依赖，定期更新，并对此负责</em></p>\n<p>1、 依赖分为node依赖和browser依赖，其实我一直区分不了这两者。后者考虑tree-sharking、产物尺寸等</p>\n<p>2、 依赖从一个维度分为间接依赖和直接依赖，锁直接依赖只能解决部分问题</p>\n<p>3、目前社区已有的解决方案</p>\n<p>1）cnpm提供的bug-versions</p>\n<p>2）npm提供的resolutions</p>\n<ol start=\"3\">\n<li>侵入式代码patch-package</li>\n</ol>\n<p><a href=\"https://www.npmjs.com/package/patch-package\">patch-package</a>，这个点学到了。因为我在实际工作中也碰到过，之前是forked的或者拷贝源码到本地，如今学到这一招<code>patch-package</code>。</p>\n<p>以下翻译自<a href=\"https://www.npmjs.com/package/patch-package\">patch-package</a></p>\n<h2 id=\"patch-package\"><a href=\"#patch-package\" class=\"headerlink\" title=\"patch-package\"></a>patch-package</h2><h3 id=\"Patch-相比-forked，好处在于\"><a href=\"#Patch-相比-forked，好处在于\" class=\"headerlink\" title=\"Patch 相比 forked，好处在于\"></a>Patch 相比 forked，好处在于</h3><ul>\n<li><p>有时forked是需要额外的构建步骤</p>\n</li>\n<li><p>当依赖发生变化的时候，会告诉你一个红色的提示，让你检查你的修复是否依然有效</p>\n</li>\n<li><p>将你的补丁与依赖它们的代码放在一起。</p>\n</li>\n<li><p>patches 可以是正常review过程中的一部分，但是forked 不会</p>\n</li>\n</ul>\n<h3 id=\"什么时候使用forked\"><a href=\"#什么时候使用forked\" class=\"headerlink\" title=\"什么时候使用forked\"></a>什么时候使用forked</h3><ul>\n<li><p>变化太大了无法原地开发</p>\n</li>\n<li><p>这种变化对他人有用</p>\n</li>\n<li><p>你可以创建一个合适的pr</p>\n</li>\n</ul>\n<h3 id=\"Patch-有危险吗\"><a href=\"#Patch-有危险吗\" class=\"headerlink\" title=\"Patch 有危险吗\"></a>Patch 有危险吗</h3><p>不会.有几个点必须要记住</p>\n<ul>\n<li><p>在有没有patch文件的分支切换时，很容易忘记运行<code>yarn</code> or <code>npm</code></p>\n</li>\n<li><p>如果长期的补丁影响到一个定期更新的代码区域，而你也想定期更新软件包，那么维护的成本就会很高。</p>\n</li>\n<li><p>大的semantic变化很难review，让它们小而且明显，或者添加注释</p>\n</li>\n<li><p>改变也会影响其他未触及的软件包的行为。通常情况下，这种情况会很明显，而且往往是希望如此，但还是要小心。（这句翻译好生硬，西巴）</p>\n</li>\n</ul>\n<h2 id=\"umi本身自己是怎么解决的\"><a href=\"#umi本身自己是怎么解决的\" class=\"headerlink\" title=\"umi本身自己是怎么解决的\"></a>umi本身自己是怎么解决的</h2><blockquote>\n<p>背后主要是uⅱ层对依赖做了彻底锁，包含间接依赖，通过预打包依赖的方式，就算再过10年，也不会出现因node依赖更新导致umi挂的情况。此外还有些细节，比如babel runtime和polyfill等browser依赖的锁定等。</p>\n</blockquote>\n<p> ###能套用到browser吗？</p>\n<p>不能。因为预打包会让tree-shaking失效。node库大部分能在流程中发现，但是browser库必须要到线上才能发现。</p>\n<blockquote>\n<p>所以importmaps锁+有人担保的类xx-antd中间依赖+灰度可能是browser依赖的完美解。至于为什么procode为啥直接用x-antd不完美？因为间接依赖没锁。</p>\n</blockquote>\n<p>哎，学习学着学着就发散了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>原文链接：<a href=\"https://wx.zsxq.com/dweb2/index/topic_detail/185452122241212\">依赖版本锁不锁</a></p>\n<p>本来只是看下依赖预打包是怎么回事，然后被迫又重新读了这篇文章。有几点值得思考的</p>\n<h2 id=\"关于依赖版本到底锁不锁，锁？如何保持更新，不锁？如何保持稳定\"><a href=\"#关于依赖版本到底锁不锁，锁？如何保持更新，不锁？如何保持稳定\" class=\"headerlink\" title=\"关于依赖版本到底锁不锁，锁？如何保持更新，不锁？如何保持稳定\"></a>关于依赖版本到底锁不锁，锁？如何保持更新，不锁？如何保持稳定</h2><p> <em>中间商锁依赖，定期更新，并对此负责</em></p>\n<p>1、 依赖分为node依赖和browser依赖，其实我一直区分不了这两者。后者考虑tree-sharking、产物尺寸等</p>\n<p>2、 依赖从一个维度分为间接依赖和直接依赖，锁直接依赖只能解决部分问题</p>\n<p>3、目前社区已有的解决方案</p>\n<p>1）cnpm提供的bug-versions</p>\n<p>2）npm提供的resolutions</p>\n<ol start=\"3\">\n<li>侵入式代码patch-package</li>\n</ol>\n<p><a href=\"https://www.npmjs.com/package/patch-package\">patch-package</a>，这个点学到了。因为我在实际工作中也碰到过，之前是forked的或者拷贝源码到本地，如今学到这一招<code>patch-package</code>。</p>\n<p>以下翻译自<a href=\"https://www.npmjs.com/package/patch-package\">patch-package</a></p>\n<h2 id=\"patch-package\"><a href=\"#patch-package\" class=\"headerlink\" title=\"patch-package\"></a>patch-package</h2><h3 id=\"Patch-相比-forked，好处在于\"><a href=\"#Patch-相比-forked，好处在于\" class=\"headerlink\" title=\"Patch 相比 forked，好处在于\"></a>Patch 相比 forked，好处在于</h3><ul>\n<li><p>有时forked是需要额外的构建步骤</p>\n</li>\n<li><p>当依赖发生变化的时候，会告诉你一个红色的提示，让你检查你的修复是否依然有效</p>\n</li>\n<li><p>将你的补丁与依赖它们的代码放在一起。</p>\n</li>\n<li><p>patches 可以是正常review过程中的一部分，但是forked 不会</p>\n</li>\n</ul>\n<h3 id=\"什么时候使用forked\"><a href=\"#什么时候使用forked\" class=\"headerlink\" title=\"什么时候使用forked\"></a>什么时候使用forked</h3><ul>\n<li><p>变化太大了无法原地开发</p>\n</li>\n<li><p>这种变化对他人有用</p>\n</li>\n<li><p>你可以创建一个合适的pr</p>\n</li>\n</ul>\n<h3 id=\"Patch-有危险吗\"><a href=\"#Patch-有危险吗\" class=\"headerlink\" title=\"Patch 有危险吗\"></a>Patch 有危险吗</h3><p>不会.有几个点必须要记住</p>\n<ul>\n<li><p>在有没有patch文件的分支切换时，很容易忘记运行<code>yarn</code> or <code>npm</code></p>\n</li>\n<li><p>如果长期的补丁影响到一个定期更新的代码区域，而你也想定期更新软件包，那么维护的成本就会很高。</p>\n</li>\n<li><p>大的semantic变化很难review，让它们小而且明显，或者添加注释</p>\n</li>\n<li><p>改变也会影响其他未触及的软件包的行为。通常情况下，这种情况会很明显，而且往往是希望如此，但还是要小心。（这句翻译好生硬，西巴）</p>\n</li>\n</ul>\n<h2 id=\"umi本身自己是怎么解决的\"><a href=\"#umi本身自己是怎么解决的\" class=\"headerlink\" title=\"umi本身自己是怎么解决的\"></a>umi本身自己是怎么解决的</h2><blockquote>\n<p>背后主要是uⅱ层对依赖做了彻底锁，包含间接依赖，通过预打包依赖的方式，就算再过10年，也不会出现因node依赖更新导致umi挂的情况。此外还有些细节，比如babel runtime和polyfill等browser依赖的锁定等。</p>\n</blockquote>\n<p> ###能套用到browser吗？</p>\n<p>不能。因为预打包会让tree-shaking失效。node库大部分能在流程中发现，但是browser库必须要到线上才能发现。</p>\n<blockquote>\n<p>所以importmaps锁+有人担保的类xx-antd中间依赖+灰度可能是browser依赖的完美解。至于为什么procode为啥直接用x-antd不完美？因为间接依赖没锁。</p>\n</blockquote>\n<p>哎，学习学着学着就发散了</p>\n"},{"title":"切换node版本","date":"2022-06-04T02:42:36.000Z","_content":"## n\n\n```\nnpm install -g n\n```\n\n```\nn x.x.x 安装某个版本\n\nn lts 安装最新版本\n\nn stable 安装稳定版本lts\n\nn rm x.x.x 删除某个版本\n\nn use 16.14.2\n\nn 可以查看所有已安装的node版本，可以根据上下和回车选择要使用的版本\n\nn ls-remote --all 查看服务器上所有可用的版本\n\n```\n\n\n`n ls-remote --all`这个命令真香，可以查看目前所有的node版本\n\n\n## nvm\n\n\n\nNode 版本管理器是一个用于管理多个已发布的 Node.js 不同版本的 bash 脚本。它允许你执行诸如“安装”、“卸载”以及“版本切换”等诸多功能。 使用[安装脚本](https://github.com/nvm-sh/nvm#install--update-script)安装 nvm。\n\n对于 Unix / OS X 系统，Node.js 从源代码构建，并通过 [nvm](https://github.com/creationix/nvm) 安装到你所期望的地方。\n\n```\nenv VERSION=`python tools/getnodeversion.py` make install DESTDIR=`nvm_version_path v$VERSION` PREFIX=\"\"\n```\n\n随后你可以通过 `nvm` 在“发布版本”和“从源代码构建版本”中选择。\n\n举个例子，如果你的 Node.js 版本是 v8.0.0-pre：\n\n```\nnvm use 8\n```\n\n一旦官方发布了版本，并且你希望卸载从源代码编译的版本，可以这样做：\n\n```\nnvm uninstall 8\n```\n\n这个安装脚本比想象中复杂\n\n\n## nvs\n#### Windows[](https://nodejs.org/zh-cn/download/package-manager/#windows)\n\n`nvs`版本管理器是一个跨平台，可用于 Windows、macOS 以及形如 Unix 的操作系统。\n\n在 Windows 上安装 `nvs`，请到此 [发布页](https://github.com/jasongin/nvs/releases) 下载最新发布的 MSI 安装源。\n\n你也可以使用 `chocolatey` 进行安装：\n\n```\nchoco install nvs\n```\n\n#### macOS，UnixLike[](https://nodejs.org/zh-cn/download/package-manager/#macos-unixlike)\n\n你可以在 [此处](https://github.com/jasongin/nvs/blob/master/doc/SETUP.md#mac-linux) 找到关于在 macOS / 形如 Unix 操作系统的安装步骤文档。\n\n#### 使用方法\n\n安装完成后，你可以使用 `nvs` 在不同版本的 node 中来回切换。\n\n添加最新版本的 node：\n\n```\nnvs add latest\n```\n\n添加最新 LTS 版本的 node：\n\n```\nnvs add lts\n```\n\n然后运行 `nvs use` ，为当前脚本的 `PATH` 路径下添加一个 node 版本：\n\n```\n$ nvs use lts\nPATH -= %LOCALAPPDATA%\\nvs\\default\nPATH += %LOCALAPPDATA%\\nvs\\node\\14.17.0\\x64\n```\n\n如果需要永久在 `PATH` 里添加，使用 `nvs link`：\n\n```\nnvs link lts\n```\n\n\n\n我最常用还是`n`\n\n\n## 链接\n\n[package-manager](https://nodejs.org/zh-cn/download/package-manager)\n\n[nvs](https://github.com/jasongin/nvs)\n\n[nvm](https://github.com/nvm-sh/nvm)\n\n[n](https://github.com/tj/n)","source":"_posts/切换node版本.md","raw":"---\ntitle: 切换node版本\ndate: 2022-06-04 10:42:36\ntags: node\n---\n## n\n\n```\nnpm install -g n\n```\n\n```\nn x.x.x 安装某个版本\n\nn lts 安装最新版本\n\nn stable 安装稳定版本lts\n\nn rm x.x.x 删除某个版本\n\nn use 16.14.2\n\nn 可以查看所有已安装的node版本，可以根据上下和回车选择要使用的版本\n\nn ls-remote --all 查看服务器上所有可用的版本\n\n```\n\n\n`n ls-remote --all`这个命令真香，可以查看目前所有的node版本\n\n\n## nvm\n\n\n\nNode 版本管理器是一个用于管理多个已发布的 Node.js 不同版本的 bash 脚本。它允许你执行诸如“安装”、“卸载”以及“版本切换”等诸多功能。 使用[安装脚本](https://github.com/nvm-sh/nvm#install--update-script)安装 nvm。\n\n对于 Unix / OS X 系统，Node.js 从源代码构建，并通过 [nvm](https://github.com/creationix/nvm) 安装到你所期望的地方。\n\n```\nenv VERSION=`python tools/getnodeversion.py` make install DESTDIR=`nvm_version_path v$VERSION` PREFIX=\"\"\n```\n\n随后你可以通过 `nvm` 在“发布版本”和“从源代码构建版本”中选择。\n\n举个例子，如果你的 Node.js 版本是 v8.0.0-pre：\n\n```\nnvm use 8\n```\n\n一旦官方发布了版本，并且你希望卸载从源代码编译的版本，可以这样做：\n\n```\nnvm uninstall 8\n```\n\n这个安装脚本比想象中复杂\n\n\n## nvs\n#### Windows[](https://nodejs.org/zh-cn/download/package-manager/#windows)\n\n`nvs`版本管理器是一个跨平台，可用于 Windows、macOS 以及形如 Unix 的操作系统。\n\n在 Windows 上安装 `nvs`，请到此 [发布页](https://github.com/jasongin/nvs/releases) 下载最新发布的 MSI 安装源。\n\n你也可以使用 `chocolatey` 进行安装：\n\n```\nchoco install nvs\n```\n\n#### macOS，UnixLike[](https://nodejs.org/zh-cn/download/package-manager/#macos-unixlike)\n\n你可以在 [此处](https://github.com/jasongin/nvs/blob/master/doc/SETUP.md#mac-linux) 找到关于在 macOS / 形如 Unix 操作系统的安装步骤文档。\n\n#### 使用方法\n\n安装完成后，你可以使用 `nvs` 在不同版本的 node 中来回切换。\n\n添加最新版本的 node：\n\n```\nnvs add latest\n```\n\n添加最新 LTS 版本的 node：\n\n```\nnvs add lts\n```\n\n然后运行 `nvs use` ，为当前脚本的 `PATH` 路径下添加一个 node 版本：\n\n```\n$ nvs use lts\nPATH -= %LOCALAPPDATA%\\nvs\\default\nPATH += %LOCALAPPDATA%\\nvs\\node\\14.17.0\\x64\n```\n\n如果需要永久在 `PATH` 里添加，使用 `nvs link`：\n\n```\nnvs link lts\n```\n\n\n\n我最常用还是`n`\n\n\n## 链接\n\n[package-manager](https://nodejs.org/zh-cn/download/package-manager)\n\n[nvs](https://github.com/jasongin/nvs)\n\n[nvm](https://github.com/nvm-sh/nvm)\n\n[n](https://github.com/tj/n)","slug":"切换node版本","published":1,"updated":"2022-06-04T11:38:20.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3zvhuz40009kiwx3w49gqnt","content":"<h2 id=\"n\"><a href=\"#n\" class=\"headerlink\" title=\"n\"></a>n</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g n</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n x.x.x 安装某个版本</span><br><span class=\"line\"></span><br><span class=\"line\">n lts 安装最新版本</span><br><span class=\"line\"></span><br><span class=\"line\">n stable 安装稳定版本lts</span><br><span class=\"line\"></span><br><span class=\"line\">n rm x.x.x 删除某个版本</span><br><span class=\"line\"></span><br><span class=\"line\">n use 16.14.2</span><br><span class=\"line\"></span><br><span class=\"line\">n 可以查看所有已安装的node版本，可以根据上下和回车选择要使用的版本</span><br><span class=\"line\"></span><br><span class=\"line\">n ls-remote --all 查看服务器上所有可用的版本</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p><code>n ls-remote --all</code>这个命令真香，可以查看目前所有的node版本</p>\n<h2 id=\"nvm\"><a href=\"#nvm\" class=\"headerlink\" title=\"nvm\"></a>nvm</h2><p>Node 版本管理器是一个用于管理多个已发布的 Node.js 不同版本的 bash 脚本。它允许你执行诸如“安装”、“卸载”以及“版本切换”等诸多功能。 使用<a href=\"https://github.com/nvm-sh/nvm#install--update-script\">安装脚本</a>安装 nvm。</p>\n<p>对于 Unix &#x2F; OS X 系统，Node.js 从源代码构建，并通过 <a href=\"https://github.com/creationix/nvm\">nvm</a> 安装到你所期望的地方。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env VERSION=`python tools/getnodeversion.py` make install DESTDIR=`nvm_version_path v$VERSION` PREFIX=&quot;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>随后你可以通过 <code>nvm</code> 在“发布版本”和“从源代码构建版本”中选择。</p>\n<p>举个例子，如果你的 Node.js 版本是 v8.0.0-pre：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm use 8</span><br></pre></td></tr></table></figure>\n\n<p>一旦官方发布了版本，并且你希望卸载从源代码编译的版本，可以这样做：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm uninstall 8</span><br></pre></td></tr></table></figure>\n\n<p>这个安装脚本比想象中复杂</p>\n<h2 id=\"nvs\"><a href=\"#nvs\" class=\"headerlink\" title=\"nvs\"></a>nvs</h2><h4 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows<a href=\"https://nodejs.org/zh-cn/download/package-manager/#windows\"></a></h4><p><code>nvs</code>版本管理器是一个跨平台，可用于 Windows、macOS 以及形如 Unix 的操作系统。</p>\n<p>在 Windows 上安装 <code>nvs</code>，请到此 <a href=\"https://github.com/jasongin/nvs/releases\">发布页</a> 下载最新发布的 MSI 安装源。</p>\n<p>你也可以使用 <code>chocolatey</code> 进行安装：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">choco install nvs</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"macOS，UnixLike\"><a href=\"#macOS，UnixLike\" class=\"headerlink\" title=\"macOS，UnixLike\"></a>macOS，UnixLike<a href=\"https://nodejs.org/zh-cn/download/package-manager/#macos-unixlike\"></a></h4><p>你可以在 <a href=\"https://github.com/jasongin/nvs/blob/master/doc/SETUP.md#mac-linux\">此处</a> 找到关于在 macOS &#x2F; 形如 Unix 操作系统的安装步骤文档。</p>\n<h4 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h4><p>安装完成后，你可以使用 <code>nvs</code> 在不同版本的 node 中来回切换。</p>\n<p>添加最新版本的 node：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvs add latest</span><br></pre></td></tr></table></figure>\n\n<p>添加最新 LTS 版本的 node：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvs add lts</span><br></pre></td></tr></table></figure>\n\n<p>然后运行 <code>nvs use</code> ，为当前脚本的 <code>PATH</code> 路径下添加一个 node 版本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nvs use lts</span><br><span class=\"line\">PATH -= %LOCALAPPDATA%\\nvs\\default</span><br><span class=\"line\">PATH += %LOCALAPPDATA%\\nvs\\node\\14.17.0\\x64</span><br></pre></td></tr></table></figure>\n\n<p>如果需要永久在 <code>PATH</code> 里添加，使用 <code>nvs link</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvs link lts</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我最常用还是<code>n</code></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://nodejs.org/zh-cn/download/package-manager\">package-manager</a></p>\n<p><a href=\"https://github.com/jasongin/nvs\">nvs</a></p>\n<p><a href=\"https://github.com/nvm-sh/nvm\">nvm</a></p>\n<p><a href=\"https://github.com/tj/n\">n</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"n\"><a href=\"#n\" class=\"headerlink\" title=\"n\"></a>n</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g n</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n x.x.x 安装某个版本</span><br><span class=\"line\"></span><br><span class=\"line\">n lts 安装最新版本</span><br><span class=\"line\"></span><br><span class=\"line\">n stable 安装稳定版本lts</span><br><span class=\"line\"></span><br><span class=\"line\">n rm x.x.x 删除某个版本</span><br><span class=\"line\"></span><br><span class=\"line\">n use 16.14.2</span><br><span class=\"line\"></span><br><span class=\"line\">n 可以查看所有已安装的node版本，可以根据上下和回车选择要使用的版本</span><br><span class=\"line\"></span><br><span class=\"line\">n ls-remote --all 查看服务器上所有可用的版本</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p><code>n ls-remote --all</code>这个命令真香，可以查看目前所有的node版本</p>\n<h2 id=\"nvm\"><a href=\"#nvm\" class=\"headerlink\" title=\"nvm\"></a>nvm</h2><p>Node 版本管理器是一个用于管理多个已发布的 Node.js 不同版本的 bash 脚本。它允许你执行诸如“安装”、“卸载”以及“版本切换”等诸多功能。 使用<a href=\"https://github.com/nvm-sh/nvm#install--update-script\">安装脚本</a>安装 nvm。</p>\n<p>对于 Unix &#x2F; OS X 系统，Node.js 从源代码构建，并通过 <a href=\"https://github.com/creationix/nvm\">nvm</a> 安装到你所期望的地方。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env VERSION=`python tools/getnodeversion.py` make install DESTDIR=`nvm_version_path v$VERSION` PREFIX=&quot;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>随后你可以通过 <code>nvm</code> 在“发布版本”和“从源代码构建版本”中选择。</p>\n<p>举个例子，如果你的 Node.js 版本是 v8.0.0-pre：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm use 8</span><br></pre></td></tr></table></figure>\n\n<p>一旦官方发布了版本，并且你希望卸载从源代码编译的版本，可以这样做：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm uninstall 8</span><br></pre></td></tr></table></figure>\n\n<p>这个安装脚本比想象中复杂</p>\n<h2 id=\"nvs\"><a href=\"#nvs\" class=\"headerlink\" title=\"nvs\"></a>nvs</h2><h4 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows<a href=\"https://nodejs.org/zh-cn/download/package-manager/#windows\"></a></h4><p><code>nvs</code>版本管理器是一个跨平台，可用于 Windows、macOS 以及形如 Unix 的操作系统。</p>\n<p>在 Windows 上安装 <code>nvs</code>，请到此 <a href=\"https://github.com/jasongin/nvs/releases\">发布页</a> 下载最新发布的 MSI 安装源。</p>\n<p>你也可以使用 <code>chocolatey</code> 进行安装：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">choco install nvs</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"macOS，UnixLike\"><a href=\"#macOS，UnixLike\" class=\"headerlink\" title=\"macOS，UnixLike\"></a>macOS，UnixLike<a href=\"https://nodejs.org/zh-cn/download/package-manager/#macos-unixlike\"></a></h4><p>你可以在 <a href=\"https://github.com/jasongin/nvs/blob/master/doc/SETUP.md#mac-linux\">此处</a> 找到关于在 macOS &#x2F; 形如 Unix 操作系统的安装步骤文档。</p>\n<h4 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h4><p>安装完成后，你可以使用 <code>nvs</code> 在不同版本的 node 中来回切换。</p>\n<p>添加最新版本的 node：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvs add latest</span><br></pre></td></tr></table></figure>\n\n<p>添加最新 LTS 版本的 node：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvs add lts</span><br></pre></td></tr></table></figure>\n\n<p>然后运行 <code>nvs use</code> ，为当前脚本的 <code>PATH</code> 路径下添加一个 node 版本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nvs use lts</span><br><span class=\"line\">PATH -= %LOCALAPPDATA%\\nvs\\default</span><br><span class=\"line\">PATH += %LOCALAPPDATA%\\nvs\\node\\14.17.0\\x64</span><br></pre></td></tr></table></figure>\n\n<p>如果需要永久在 <code>PATH</code> 里添加，使用 <code>nvs link</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvs link lts</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我最常用还是<code>n</code></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://nodejs.org/zh-cn/download/package-manager\">package-manager</a></p>\n<p><a href=\"https://github.com/jasongin/nvs\">nvs</a></p>\n<p><a href=\"https://github.com/nvm-sh/nvm\">nvm</a></p>\n<p><a href=\"https://github.com/tj/n\">n</a></p>\n"},{"title":"如何在git本地配置多个SSH keys","date":"2022-06-04T11:19:48.000Z","_content":"\n## 背景\n\n公司用 gitlab，git 的地址用的 ssh 地址。众所周知，用 ssh 地址的话则需要在本地产生一个私钥和公钥；而自己的项目用的是 github，git 也用的是 ssh 地址\n那么这个时候小心你的 .ssh 不要被覆盖了\n\n## 具体步骤\n\n### 生成一个 github 的 SSH key\n\n```\nssh-keygen -t rsa -C '你github绑定的邮箱' -f ~/.ssh/github_id_rsa\n```\n\n### 生成一个 gitlab 的 SSH key\n\n``` js\n\nssh-keygen -t rsa -C '你公司绑定的邮箱' -f ~/.ssh/gitlab_id_rsa\n```\n\n几个参数介绍\n\n```\n-t 指定密钥类型，默认是 rsa ，可以省略。\n-C 设置注释文字，比如邮箱。\n-f 指定密钥文件存储文件名\n```\n\n\n### 在.ssh下新建一个 config 的文件\n\n```\ntouch config\n\n// 把以下拷贝进去\n# github\nHost github.com\nHostName github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/github_id_rsa\n\n# gitlab\nHost gitlab.xx\nHostName gitlab.xx\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/gitlab_id_rsa\n```\n\n以上步骤正常的话，你就会在~/.ssh 下面看到\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/185ce412a57b41339109dbcee53a5fa5~tplv-k3u1fbpfcp-watermark.image)\n\n### 分别在gitlab和github上配置SSH keys\n\n拷贝公钥，记住是 `id_rsa.pub`,不要拷贝错了\n\n#### github\nsettings->SSH and GPG keys->New SSH key\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/557b0341fdd347b19d351caac3466f93~tplv-k3u1fbpfcp-watermark.image)\n\n#### gitlab 也是如此\n\n## 参考\n[Git配置多个SSH-Key](https://gitee.com/help/articles/4229#article-header0)\n\n[服务器上的 Git - 生成 SSH 公钥](https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5)\n\n\n\n## 修改hosts文件\n\n```\nsudo vim /etc/hosts\n```\n","source":"_posts/如何在git本地配置多个SSH-keys.md","raw":"---\ntitle: 如何在git本地配置多个SSH keys\ndate: 2022-06-04 19:19:48\ntags: git\n---\n\n## 背景\n\n公司用 gitlab，git 的地址用的 ssh 地址。众所周知，用 ssh 地址的话则需要在本地产生一个私钥和公钥；而自己的项目用的是 github，git 也用的是 ssh 地址\n那么这个时候小心你的 .ssh 不要被覆盖了\n\n## 具体步骤\n\n### 生成一个 github 的 SSH key\n\n```\nssh-keygen -t rsa -C '你github绑定的邮箱' -f ~/.ssh/github_id_rsa\n```\n\n### 生成一个 gitlab 的 SSH key\n\n``` js\n\nssh-keygen -t rsa -C '你公司绑定的邮箱' -f ~/.ssh/gitlab_id_rsa\n```\n\n几个参数介绍\n\n```\n-t 指定密钥类型，默认是 rsa ，可以省略。\n-C 设置注释文字，比如邮箱。\n-f 指定密钥文件存储文件名\n```\n\n\n### 在.ssh下新建一个 config 的文件\n\n```\ntouch config\n\n// 把以下拷贝进去\n# github\nHost github.com\nHostName github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/github_id_rsa\n\n# gitlab\nHost gitlab.xx\nHostName gitlab.xx\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/gitlab_id_rsa\n```\n\n以上步骤正常的话，你就会在~/.ssh 下面看到\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/185ce412a57b41339109dbcee53a5fa5~tplv-k3u1fbpfcp-watermark.image)\n\n### 分别在gitlab和github上配置SSH keys\n\n拷贝公钥，记住是 `id_rsa.pub`,不要拷贝错了\n\n#### github\nsettings->SSH and GPG keys->New SSH key\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/557b0341fdd347b19d351caac3466f93~tplv-k3u1fbpfcp-watermark.image)\n\n#### gitlab 也是如此\n\n## 参考\n[Git配置多个SSH-Key](https://gitee.com/help/articles/4229#article-header0)\n\n[服务器上的 Git - 生成 SSH 公钥](https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5)\n\n\n\n## 修改hosts文件\n\n```\nsudo vim /etc/hosts\n```\n","slug":"如何在git本地配置多个SSH-keys","published":1,"updated":"2022-06-04T11:38:20.583Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3zvhuz4000bkiwx37iha1mb","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>公司用 gitlab，git 的地址用的 ssh 地址。众所周知，用 ssh 地址的话则需要在本地产生一个私钥和公钥；而自己的项目用的是 github，git 也用的是 ssh 地址<br>那么这个时候小心你的 .ssh 不要被覆盖了</p>\n<h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><h3 id=\"生成一个-github-的-SSH-key\"><a href=\"#生成一个-github-的-SSH-key\" class=\"headerlink\" title=\"生成一个 github 的 SSH key\"></a>生成一个 github 的 SSH key</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &#x27;你github绑定的邮箱&#x27; -f ~/.ssh/github_id_rsa</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生成一个-gitlab-的-SSH-key\"><a href=\"#生成一个-gitlab-的-SSH-key\" class=\"headerlink\" title=\"生成一个 gitlab 的 SSH key\"></a>生成一个 gitlab 的 SSH key</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ssh-keygen -t rsa -C <span class=\"string\">&#x27;你公司绑定的邮箱&#x27;</span> -f ~<span class=\"regexp\">/.ssh/gi</span>tlab_id_rsa</span><br></pre></td></tr></table></figure>\n\n<p>几个参数介绍</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-t 指定密钥类型，默认是 rsa ，可以省略。</span><br><span class=\"line\">-C 设置注释文字，比如邮箱。</span><br><span class=\"line\">-f 指定密钥文件存储文件名</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"在-ssh下新建一个-config-的文件\"><a href=\"#在-ssh下新建一个-config-的文件\" class=\"headerlink\" title=\"在.ssh下新建一个 config 的文件\"></a>在.ssh下新建一个 config 的文件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch config</span><br><span class=\"line\"></span><br><span class=\"line\">// 把以下拷贝进去</span><br><span class=\"line\"># github</span><br><span class=\"line\">Host github.com</span><br><span class=\"line\">HostName github.com</span><br><span class=\"line\">PreferredAuthentications publickey</span><br><span class=\"line\">IdentityFile ~/.ssh/github_id_rsa</span><br><span class=\"line\"></span><br><span class=\"line\"># gitlab</span><br><span class=\"line\">Host gitlab.xx</span><br><span class=\"line\">HostName gitlab.xx</span><br><span class=\"line\">PreferredAuthentications publickey</span><br><span class=\"line\">IdentityFile ~/.ssh/gitlab_id_rsa</span><br></pre></td></tr></table></figure>\n\n<p>以上步骤正常的话，你就会在~&#x2F;.ssh 下面看到</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/185ce412a57b41339109dbcee53a5fa5~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3 id=\"分别在gitlab和github上配置SSH-keys\"><a href=\"#分别在gitlab和github上配置SSH-keys\" class=\"headerlink\" title=\"分别在gitlab和github上配置SSH keys\"></a>分别在gitlab和github上配置SSH keys</h3><p>拷贝公钥，记住是 <code>id_rsa.pub</code>,不要拷贝错了</p>\n<h4 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h4><p>settings-&gt;SSH and GPG keys-&gt;New SSH key</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/557b0341fdd347b19d351caac3466f93~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h4 id=\"gitlab-也是如此\"><a href=\"#gitlab-也是如此\" class=\"headerlink\" title=\"gitlab 也是如此\"></a>gitlab 也是如此</h4><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://gitee.com/help/articles/4229#article-header0\">Git配置多个SSH-Key</a></p>\n<p><a href=\"https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5\">服务器上的 Git - 生成 SSH 公钥</a></p>\n<h2 id=\"修改hosts文件\"><a href=\"#修改hosts文件\" class=\"headerlink\" title=\"修改hosts文件\"></a>修改hosts文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>公司用 gitlab，git 的地址用的 ssh 地址。众所周知，用 ssh 地址的话则需要在本地产生一个私钥和公钥；而自己的项目用的是 github，git 也用的是 ssh 地址<br>那么这个时候小心你的 .ssh 不要被覆盖了</p>\n<h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><h3 id=\"生成一个-github-的-SSH-key\"><a href=\"#生成一个-github-的-SSH-key\" class=\"headerlink\" title=\"生成一个 github 的 SSH key\"></a>生成一个 github 的 SSH key</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &#x27;你github绑定的邮箱&#x27; -f ~/.ssh/github_id_rsa</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生成一个-gitlab-的-SSH-key\"><a href=\"#生成一个-gitlab-的-SSH-key\" class=\"headerlink\" title=\"生成一个 gitlab 的 SSH key\"></a>生成一个 gitlab 的 SSH key</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ssh-keygen -t rsa -C <span class=\"string\">&#x27;你公司绑定的邮箱&#x27;</span> -f ~<span class=\"regexp\">/.ssh/gi</span>tlab_id_rsa</span><br></pre></td></tr></table></figure>\n\n<p>几个参数介绍</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-t 指定密钥类型，默认是 rsa ，可以省略。</span><br><span class=\"line\">-C 设置注释文字，比如邮箱。</span><br><span class=\"line\">-f 指定密钥文件存储文件名</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"在-ssh下新建一个-config-的文件\"><a href=\"#在-ssh下新建一个-config-的文件\" class=\"headerlink\" title=\"在.ssh下新建一个 config 的文件\"></a>在.ssh下新建一个 config 的文件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch config</span><br><span class=\"line\"></span><br><span class=\"line\">// 把以下拷贝进去</span><br><span class=\"line\"># github</span><br><span class=\"line\">Host github.com</span><br><span class=\"line\">HostName github.com</span><br><span class=\"line\">PreferredAuthentications publickey</span><br><span class=\"line\">IdentityFile ~/.ssh/github_id_rsa</span><br><span class=\"line\"></span><br><span class=\"line\"># gitlab</span><br><span class=\"line\">Host gitlab.xx</span><br><span class=\"line\">HostName gitlab.xx</span><br><span class=\"line\">PreferredAuthentications publickey</span><br><span class=\"line\">IdentityFile ~/.ssh/gitlab_id_rsa</span><br></pre></td></tr></table></figure>\n\n<p>以上步骤正常的话，你就会在~&#x2F;.ssh 下面看到</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/185ce412a57b41339109dbcee53a5fa5~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3 id=\"分别在gitlab和github上配置SSH-keys\"><a href=\"#分别在gitlab和github上配置SSH-keys\" class=\"headerlink\" title=\"分别在gitlab和github上配置SSH keys\"></a>分别在gitlab和github上配置SSH keys</h3><p>拷贝公钥，记住是 <code>id_rsa.pub</code>,不要拷贝错了</p>\n<h4 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h4><p>settings-&gt;SSH and GPG keys-&gt;New SSH key</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/557b0341fdd347b19d351caac3466f93~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h4 id=\"gitlab-也是如此\"><a href=\"#gitlab-也是如此\" class=\"headerlink\" title=\"gitlab 也是如此\"></a>gitlab 也是如此</h4><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://gitee.com/help/articles/4229#article-header0\">Git配置多个SSH-Key</a></p>\n<p><a href=\"https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5\">服务器上的 Git - 生成 SSH 公钥</a></p>\n<h2 id=\"修改hosts文件\"><a href=\"#修改hosts文件\" class=\"headerlink\" title=\"修改hosts文件\"></a>修改hosts文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure>\n"},{"title":"如何实现一个babel plugin","date":"2022-06-04T10:17:36.000Z","_content":"\n最近在学[zxg_神说要有光](https://juejin.cn/user/2788017216685118)的babel通关秘籍\n\n首先推荐一个非常有用的网站\n\n[astexplorer](https://astexplorer.net/)\n\n这个网站能我们实现一个plugin 以及AST的分类图能给我们写插件提供帮助\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b29b0bb6151840d9b75cf79703fa9cdc~tplv-k3u1fbpfcp-watermark.image?)\n\n无非是对各个AST节点进行逻辑处理，实现我们想要的功能\n\n举例，比如我们要实现自动生成文档\n\n``` js\n/**\n * say 你好\n * @param name 名字\n */\n function sayHi (name: string, age: number, a: boolean):string {\n  console.log(`hi, ${name}`);\n  return `hi, ${name}`;\n}\n\n```\n\n期望得到\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70c24bc542974e1e8abd1f7072ff57ef~tplv-k3u1fbpfcp-watermark.image?)\n\n\n我们把这段逻辑复制到[astexplorer](https://astexplorer.net/#/gist/b0d57d7558f7751699100200a14e523c/860789f4d6f1b19523d86eccd4d40838e975d4f4)\n\n \n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daef6d0643e94ab49137e7f6a7e4af78~tplv-k3u1fbpfcp-watermark.image?)\n\n可以得知我们处理`FunctionDeclaration`，它有两个重要的参数\n\n``` js\n// path 获取节点的信息\n// state 节点的状态\n  FunctionDeclaration(path, state)\n```\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6822abaca28a437690ced0f35a175914~tplv-k3u1fbpfcp-watermark.image?)\n\n- 获取函数名字path.get(\"id\").toString()\n- 获取函数的入参path.get(\"params\")\n- 获取函数的返回类型path.get(\"returnType\").getTypeAnnotation()\n\n\n``` js\n// 函数的形式\nconst { declare } = require(\"@babel/helper-plugin-utils\");\nconst doctrine = require(\"doctrine\");\nconst fse = require(\"fs-extra\");\nconst path = require(\"path\");\nconst renderer = require(\"./renderer\");\n\nconst autoDocumentPlugin = declare((api, options, dirname) => {\n  api.assertVersion(7);\n\n  return {\n    pre(file) {  // 初始化插件返回的信息\n      file.set(\"docs\", []);\n    },\n    visitor: {\n      FunctionDeclaration(path, state) {\n        const docs = state.file.get(\"docs\");\n        docs.push({\n          type: \"function\",\n          name: path.get(\"id\").toString(), // 获取函数名\n          // 获取函数的参数\n          params: path.get(\"params\").map((paramPath) => {\n            return {\n              name: paramPath.toString(),\n              // paramPath.getTypeAnnotation() 参数的类型\n              type: resolveType(paramPath.getTypeAnnotation()),\n            };\n          }),\n          //  返回参数的类型\n          return: resolveType(path.get(\"returnType\").getTypeAnnotation()),\n          doc:\n            // 注释信息单独处理\n            path.node.leadingComments &&\n            parseComment(path.node.leadingComments[0].value),\n        });\n        state.file.set(\"docs\", docs);\n        },\n   \n    },\n    post(file) {   //  最后返回结果的处理\n      const docs = file.get(\"docs\");\n      const res = generate(docs, options.format);\n      fse.ensureDirSync(options.outputDir);\n      fse.writeFileSync(\n        path.join(options.outputDir, \"docs\" + res.ext),\n        res.content\n      );\n    },\n  };\n});\n\nmodule.exports = autoDocumentPlugin;\n```\n    \n 注释的处理\n 使用doctrine\n ``` js\n \n//  处理注释信息\nfunction parseComment(commentStr) {\n  if (!commentStr) {\n    return;\n  }\n  return doctrine.parse(commentStr, {\n    unwrap: true,\n  });\n}\n ```\n \n思考：实际工作中需要写一个plugin插件不\n    ","source":"_posts/如何实现一个babel-plugin.md","raw":"---\ntitle: 如何实现一个babel plugin\ndate: 2022-06-04 18:17:36\ntags: babel\n---\n\n最近在学[zxg_神说要有光](https://juejin.cn/user/2788017216685118)的babel通关秘籍\n\n首先推荐一个非常有用的网站\n\n[astexplorer](https://astexplorer.net/)\n\n这个网站能我们实现一个plugin 以及AST的分类图能给我们写插件提供帮助\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b29b0bb6151840d9b75cf79703fa9cdc~tplv-k3u1fbpfcp-watermark.image?)\n\n无非是对各个AST节点进行逻辑处理，实现我们想要的功能\n\n举例，比如我们要实现自动生成文档\n\n``` js\n/**\n * say 你好\n * @param name 名字\n */\n function sayHi (name: string, age: number, a: boolean):string {\n  console.log(`hi, ${name}`);\n  return `hi, ${name}`;\n}\n\n```\n\n期望得到\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70c24bc542974e1e8abd1f7072ff57ef~tplv-k3u1fbpfcp-watermark.image?)\n\n\n我们把这段逻辑复制到[astexplorer](https://astexplorer.net/#/gist/b0d57d7558f7751699100200a14e523c/860789f4d6f1b19523d86eccd4d40838e975d4f4)\n\n \n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daef6d0643e94ab49137e7f6a7e4af78~tplv-k3u1fbpfcp-watermark.image?)\n\n可以得知我们处理`FunctionDeclaration`，它有两个重要的参数\n\n``` js\n// path 获取节点的信息\n// state 节点的状态\n  FunctionDeclaration(path, state)\n```\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6822abaca28a437690ced0f35a175914~tplv-k3u1fbpfcp-watermark.image?)\n\n- 获取函数名字path.get(\"id\").toString()\n- 获取函数的入参path.get(\"params\")\n- 获取函数的返回类型path.get(\"returnType\").getTypeAnnotation()\n\n\n``` js\n// 函数的形式\nconst { declare } = require(\"@babel/helper-plugin-utils\");\nconst doctrine = require(\"doctrine\");\nconst fse = require(\"fs-extra\");\nconst path = require(\"path\");\nconst renderer = require(\"./renderer\");\n\nconst autoDocumentPlugin = declare((api, options, dirname) => {\n  api.assertVersion(7);\n\n  return {\n    pre(file) {  // 初始化插件返回的信息\n      file.set(\"docs\", []);\n    },\n    visitor: {\n      FunctionDeclaration(path, state) {\n        const docs = state.file.get(\"docs\");\n        docs.push({\n          type: \"function\",\n          name: path.get(\"id\").toString(), // 获取函数名\n          // 获取函数的参数\n          params: path.get(\"params\").map((paramPath) => {\n            return {\n              name: paramPath.toString(),\n              // paramPath.getTypeAnnotation() 参数的类型\n              type: resolveType(paramPath.getTypeAnnotation()),\n            };\n          }),\n          //  返回参数的类型\n          return: resolveType(path.get(\"returnType\").getTypeAnnotation()),\n          doc:\n            // 注释信息单独处理\n            path.node.leadingComments &&\n            parseComment(path.node.leadingComments[0].value),\n        });\n        state.file.set(\"docs\", docs);\n        },\n   \n    },\n    post(file) {   //  最后返回结果的处理\n      const docs = file.get(\"docs\");\n      const res = generate(docs, options.format);\n      fse.ensureDirSync(options.outputDir);\n      fse.writeFileSync(\n        path.join(options.outputDir, \"docs\" + res.ext),\n        res.content\n      );\n    },\n  };\n});\n\nmodule.exports = autoDocumentPlugin;\n```\n    \n 注释的处理\n 使用doctrine\n ``` js\n \n//  处理注释信息\nfunction parseComment(commentStr) {\n  if (!commentStr) {\n    return;\n  }\n  return doctrine.parse(commentStr, {\n    unwrap: true,\n  });\n}\n ```\n \n思考：实际工作中需要写一个plugin插件不\n    ","slug":"如何实现一个babel-plugin","published":1,"updated":"2022-06-04T11:38:20.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3zvhuz6000dkiwx5yfe2662","content":"<p>最近在学<a href=\"https://juejin.cn/user/2788017216685118\">zxg_神说要有光</a>的babel通关秘籍</p>\n<p>首先推荐一个非常有用的网站</p>\n<p><a href=\"https://astexplorer.net/\">astexplorer</a></p>\n<p>这个网站能我们实现一个plugin 以及AST的分类图能给我们写插件提供帮助</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b29b0bb6151840d9b75cf79703fa9cdc~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>无非是对各个AST节点进行逻辑处理，实现我们想要的功能</p>\n<p>举例，比如我们要实现自动生成文档</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * say 你好</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> name 名字</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"keyword\">function</span> <span class=\"title function_\">sayHi</span> (<span class=\"attr\">name</span>: string, <span class=\"attr\">age</span>: number, <span class=\"attr\">a</span>: boolean):string &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`hi, <span class=\"subst\">$&#123;name&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`hi, <span class=\"subst\">$&#123;name&#125;</span>`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>期望得到</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70c24bc542974e1e8abd1f7072ff57ef~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>我们把这段逻辑复制到<a href=\"https://astexplorer.net/#/gist/b0d57d7558f7751699100200a14e523c/860789f4d6f1b19523d86eccd4d40838e975d4f4\">astexplorer</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daef6d0643e94ab49137e7f6a7e4af78~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>可以得知我们处理<code>FunctionDeclaration</code>，它有两个重要的参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// path 获取节点的信息</span></span><br><span class=\"line\"><span class=\"comment\">// state 节点的状态</span></span><br><span class=\"line\">  <span class=\"title class_\">FunctionDeclaration</span>(path, state)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6822abaca28a437690ced0f35a175914~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li>获取函数名字path.get(“id”).toString()</li>\n<li>获取函数的入参path.get(“params”)</li>\n<li>获取函数的返回类型path.get(“returnType”).getTypeAnnotation()</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数的形式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; declare &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;@babel/helper-plugin-utils&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> doctrine = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;doctrine&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fse = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs-extra&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;path&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> renderer = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./renderer&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> autoDocumentPlugin = <span class=\"title function_\">declare</span>(<span class=\"function\">(<span class=\"params\">api, options, dirname</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  api.<span class=\"title function_\">assertVersion</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">pre</span>(<span class=\"params\">file</span>) &#123;  <span class=\"comment\">// 初始化插件返回的信息</span></span><br><span class=\"line\">      file.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;docs&quot;</span>, []);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">visitor</span>: &#123;</span><br><span class=\"line\">      <span class=\"title class_\">FunctionDeclaration</span>(path, state) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> docs = state.<span class=\"property\">file</span>.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;docs&quot;</span>);</span><br><span class=\"line\">        docs.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">type</span>: <span class=\"string\">&quot;function&quot;</span>,</span><br><span class=\"line\">          <span class=\"attr\">name</span>: path.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;id&quot;</span>).<span class=\"title function_\">toString</span>(), <span class=\"comment\">// 获取函数名</span></span><br><span class=\"line\">          <span class=\"comment\">// 获取函数的参数</span></span><br><span class=\"line\">          <span class=\"attr\">params</span>: path.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;params&quot;</span>).<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">paramPath</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">              <span class=\"attr\">name</span>: paramPath.<span class=\"title function_\">toString</span>(),</span><br><span class=\"line\">              <span class=\"comment\">// paramPath.getTypeAnnotation() 参数的类型</span></span><br><span class=\"line\">              <span class=\"attr\">type</span>: <span class=\"title function_\">resolveType</span>(paramPath.<span class=\"title function_\">getTypeAnnotation</span>()),</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          &#125;),</span><br><span class=\"line\">          <span class=\"comment\">//  返回参数的类型</span></span><br><span class=\"line\">          <span class=\"attr\">return</span>: <span class=\"title function_\">resolveType</span>(path.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;returnType&quot;</span>).<span class=\"title function_\">getTypeAnnotation</span>()),</span><br><span class=\"line\">          <span class=\"attr\">doc</span>:</span><br><span class=\"line\">            <span class=\"comment\">// 注释信息单独处理</span></span><br><span class=\"line\">            path.<span class=\"property\">node</span>.<span class=\"property\">leadingComments</span> &amp;&amp;</span><br><span class=\"line\">            <span class=\"title function_\">parseComment</span>(path.<span class=\"property\">node</span>.<span class=\"property\">leadingComments</span>[<span class=\"number\">0</span>].<span class=\"property\">value</span>),</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        state.<span class=\"property\">file</span>.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;docs&quot;</span>, docs);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">   </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">post</span>(<span class=\"params\">file</span>) &#123;   <span class=\"comment\">//  最后返回结果的处理</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> docs = file.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;docs&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> res = <span class=\"title function_\">generate</span>(docs, options.<span class=\"property\">format</span>);</span><br><span class=\"line\">      fse.<span class=\"title function_\">ensureDirSync</span>(options.<span class=\"property\">outputDir</span>);</span><br><span class=\"line\">      fse.<span class=\"title function_\">writeFileSync</span>(</span><br><span class=\"line\">        path.<span class=\"title function_\">join</span>(options.<span class=\"property\">outputDir</span>, <span class=\"string\">&quot;docs&quot;</span> + res.<span class=\"property\">ext</span>),</span><br><span class=\"line\">        res.<span class=\"property\">content</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = autoDocumentPlugin;</span><br></pre></td></tr></table></figure>\n<p> 注释的处理<br> 使用doctrine<br> <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//  处理注释信息</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">parseComment</span>(<span class=\"params\">commentStr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!commentStr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> doctrine.<span class=\"title function_\">parse</span>(commentStr, &#123;</span><br><span class=\"line\">    <span class=\"attr\">unwrap</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>思考：实际工作中需要写一个plugin插件不\n    </p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在学<a href=\"https://juejin.cn/user/2788017216685118\">zxg_神说要有光</a>的babel通关秘籍</p>\n<p>首先推荐一个非常有用的网站</p>\n<p><a href=\"https://astexplorer.net/\">astexplorer</a></p>\n<p>这个网站能我们实现一个plugin 以及AST的分类图能给我们写插件提供帮助</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b29b0bb6151840d9b75cf79703fa9cdc~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>无非是对各个AST节点进行逻辑处理，实现我们想要的功能</p>\n<p>举例，比如我们要实现自动生成文档</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * say 你好</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> name 名字</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"keyword\">function</span> <span class=\"title function_\">sayHi</span> (<span class=\"attr\">name</span>: string, <span class=\"attr\">age</span>: number, <span class=\"attr\">a</span>: boolean):string &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`hi, <span class=\"subst\">$&#123;name&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`hi, <span class=\"subst\">$&#123;name&#125;</span>`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>期望得到</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70c24bc542974e1e8abd1f7072ff57ef~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>我们把这段逻辑复制到<a href=\"https://astexplorer.net/#/gist/b0d57d7558f7751699100200a14e523c/860789f4d6f1b19523d86eccd4d40838e975d4f4\">astexplorer</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daef6d0643e94ab49137e7f6a7e4af78~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>可以得知我们处理<code>FunctionDeclaration</code>，它有两个重要的参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// path 获取节点的信息</span></span><br><span class=\"line\"><span class=\"comment\">// state 节点的状态</span></span><br><span class=\"line\">  <span class=\"title class_\">FunctionDeclaration</span>(path, state)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6822abaca28a437690ced0f35a175914~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li>获取函数名字path.get(“id”).toString()</li>\n<li>获取函数的入参path.get(“params”)</li>\n<li>获取函数的返回类型path.get(“returnType”).getTypeAnnotation()</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数的形式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; declare &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;@babel/helper-plugin-utils&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> doctrine = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;doctrine&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fse = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs-extra&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;path&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> renderer = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./renderer&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> autoDocumentPlugin = <span class=\"title function_\">declare</span>(<span class=\"function\">(<span class=\"params\">api, options, dirname</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  api.<span class=\"title function_\">assertVersion</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">pre</span>(<span class=\"params\">file</span>) &#123;  <span class=\"comment\">// 初始化插件返回的信息</span></span><br><span class=\"line\">      file.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;docs&quot;</span>, []);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">visitor</span>: &#123;</span><br><span class=\"line\">      <span class=\"title class_\">FunctionDeclaration</span>(path, state) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> docs = state.<span class=\"property\">file</span>.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;docs&quot;</span>);</span><br><span class=\"line\">        docs.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">type</span>: <span class=\"string\">&quot;function&quot;</span>,</span><br><span class=\"line\">          <span class=\"attr\">name</span>: path.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;id&quot;</span>).<span class=\"title function_\">toString</span>(), <span class=\"comment\">// 获取函数名</span></span><br><span class=\"line\">          <span class=\"comment\">// 获取函数的参数</span></span><br><span class=\"line\">          <span class=\"attr\">params</span>: path.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;params&quot;</span>).<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">paramPath</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">              <span class=\"attr\">name</span>: paramPath.<span class=\"title function_\">toString</span>(),</span><br><span class=\"line\">              <span class=\"comment\">// paramPath.getTypeAnnotation() 参数的类型</span></span><br><span class=\"line\">              <span class=\"attr\">type</span>: <span class=\"title function_\">resolveType</span>(paramPath.<span class=\"title function_\">getTypeAnnotation</span>()),</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          &#125;),</span><br><span class=\"line\">          <span class=\"comment\">//  返回参数的类型</span></span><br><span class=\"line\">          <span class=\"attr\">return</span>: <span class=\"title function_\">resolveType</span>(path.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;returnType&quot;</span>).<span class=\"title function_\">getTypeAnnotation</span>()),</span><br><span class=\"line\">          <span class=\"attr\">doc</span>:</span><br><span class=\"line\">            <span class=\"comment\">// 注释信息单独处理</span></span><br><span class=\"line\">            path.<span class=\"property\">node</span>.<span class=\"property\">leadingComments</span> &amp;&amp;</span><br><span class=\"line\">            <span class=\"title function_\">parseComment</span>(path.<span class=\"property\">node</span>.<span class=\"property\">leadingComments</span>[<span class=\"number\">0</span>].<span class=\"property\">value</span>),</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        state.<span class=\"property\">file</span>.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;docs&quot;</span>, docs);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">   </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">post</span>(<span class=\"params\">file</span>) &#123;   <span class=\"comment\">//  最后返回结果的处理</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> docs = file.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;docs&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> res = <span class=\"title function_\">generate</span>(docs, options.<span class=\"property\">format</span>);</span><br><span class=\"line\">      fse.<span class=\"title function_\">ensureDirSync</span>(options.<span class=\"property\">outputDir</span>);</span><br><span class=\"line\">      fse.<span class=\"title function_\">writeFileSync</span>(</span><br><span class=\"line\">        path.<span class=\"title function_\">join</span>(options.<span class=\"property\">outputDir</span>, <span class=\"string\">&quot;docs&quot;</span> + res.<span class=\"property\">ext</span>),</span><br><span class=\"line\">        res.<span class=\"property\">content</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = autoDocumentPlugin;</span><br></pre></td></tr></table></figure>\n<p> 注释的处理<br> 使用doctrine<br> <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//  处理注释信息</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">parseComment</span>(<span class=\"params\">commentStr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!commentStr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> doctrine.<span class=\"title function_\">parse</span>(commentStr, &#123;</span><br><span class=\"line\">    <span class=\"attr\">unwrap</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>思考：实际工作中需要写一个plugin插件不\n    </p>\n"},{"title":"我的第一篇文章","date":"2022-06-02T06:47:25.000Z","_content":"\n\n\nREPL 提供了一种交互地执行 JavaScript 并查看输出的方式。它可以被用作调试、测试或仅仅尝试某些东西。\n\n在命令行输入 `node `就会进入 `REPL`\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9d8f045081c48efa620c12a24130619~tplv-k3u1fbpfcp-watermark.image?)\n\n``` \n.break    Sometimes you get stuck, this gets you out\n.clear    Alias for .break\n.editor   Enter editor mode\n.exit     Exit the repl\n.help     Print this help message\n.load     Load JS from a file into the REPL session\n.save     Save all evaluated commands in this REPL session to a file\n\n```\n\n\n\n之前老是跑到浏览器的`console`，现在才发现这个，记录下","source":"_posts/我的第一篇文章.md","raw":"---\ntitle: 我的第一篇文章\ndate: 2022-06-02 14:47:25\ntags: REPL\ncategories: 技术\n---\n\n\n\nREPL 提供了一种交互地执行 JavaScript 并查看输出的方式。它可以被用作调试、测试或仅仅尝试某些东西。\n\n在命令行输入 `node `就会进入 `REPL`\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9d8f045081c48efa620c12a24130619~tplv-k3u1fbpfcp-watermark.image?)\n\n``` \n.break    Sometimes you get stuck, this gets you out\n.clear    Alias for .break\n.editor   Enter editor mode\n.exit     Exit the repl\n.help     Print this help message\n.load     Load JS from a file into the REPL session\n.save     Save all evaluated commands in this REPL session to a file\n\n```\n\n\n\n之前老是跑到浏览器的`console`，现在才发现这个，记录下","slug":"我的第一篇文章","published":1,"updated":"2022-06-04T11:38:20.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3zvhuz7000gkiwx6agm6jfa","content":"<p>REPL 提供了一种交互地执行 JavaScript 并查看输出的方式。它可以被用作调试、测试或仅仅尝试某些东西。</p>\n<p>在命令行输入 <code>node </code>就会进入 <code>REPL</code></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9d8f045081c48efa620c12a24130619~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.break    Sometimes you get stuck, this gets you out</span><br><span class=\"line\">.clear    Alias for .break</span><br><span class=\"line\">.editor   Enter editor mode</span><br><span class=\"line\">.exit     Exit the repl</span><br><span class=\"line\">.help     Print this help message</span><br><span class=\"line\">.load     Load JS from a file into the REPL session</span><br><span class=\"line\">.save     Save all evaluated commands in this REPL session to a file</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>之前老是跑到浏览器的<code>console</code>，现在才发现这个，记录下</p>\n","site":{"data":{}},"excerpt":"","more":"<p>REPL 提供了一种交互地执行 JavaScript 并查看输出的方式。它可以被用作调试、测试或仅仅尝试某些东西。</p>\n<p>在命令行输入 <code>node </code>就会进入 <code>REPL</code></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9d8f045081c48efa620c12a24130619~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.break    Sometimes you get stuck, this gets you out</span><br><span class=\"line\">.clear    Alias for .break</span><br><span class=\"line\">.editor   Enter editor mode</span><br><span class=\"line\">.exit     Exit the repl</span><br><span class=\"line\">.help     Print this help message</span><br><span class=\"line\">.load     Load JS from a file into the REPL session</span><br><span class=\"line\">.save     Save all evaluated commands in this REPL session to a file</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>之前老是跑到浏览器的<code>console</code>，现在才发现这个，记录下</p>\n"},{"title":"编译流程","date":"2022-06-04T12:40:52.000Z","_content":"\n\n## 编译流程\n\n### parse \n\n通过parse 转成AST语法树。 具体是把源代码转成转成机器能够理解的AST，这个过程分为*词法分析*、 *语法分析*\n\n\n#### 词法分析\n\n我们要源码把它分成一个个不能细分的单词（token）的过程称为*词法分析*\n\n#### 语法分析\n\n我们把token 进行递归的组装，生成AST的过程称为*词法分析*\n\n##### AST\n\n\n![AST.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dc91699e4ec4f69971b02b2c0c44651~tplv-k3u1fbpfcp-watermark.image?)\n\n#### parse的API\n\n- @babel/parser\n\n示例\n``` js\nconst parser = require('@babel/parser');\nconst ast = parser.parse(sourceCode, {\n    sourceType: 'unambiguous', // \"script\" | \"module\" | \"unambiguous\"\n    plugins: ['jsx']\n});\n```\n- sourceType的属性值\n`unambiguous` ：根据据内容是否有 import 和 export 来确定是否解析 es module 语法\n`module`： module 是解析 es module 语法\n`script`： 其他都是script\n\n- plugins\n\n如果要解析tsx 模块，那么可以这样来写\n``` js\nrequire(\"@babel/parser\").parse(\"code\",\n{ sourceType: \"module\",\n    plugins: [ \"jsx\", \"typescript\" ]\n })\n```\n\n- parse 类型声明\n\n``` js\nexport function parse(\n  input: string,\n  options?: ParserOptions\n): ParseResult<import(\"@babel/types\").File>;\n\n```\n\n[ParserOptions](https://babeljs.io/docs/en/babel-parser#options)\n\n### transform\n\n遍历AST，调用transform的各种API进行增删改查，遍历的过程中处理到不同的 AST 节点会调用注册的相应的 visitor 函数，visitor 函数里可以对 AST 节点进行增删改\n\n#### transform的API\n\n-  @babel/traverse: 遍历 AST\n\n``` js\ntraverse(ast, {\n    CallExpression:{\n    enter(path,state){}\n     }\n    }\n});\n```\n\n``` js\ntraverse(ast, {\n    CallExpression(path, state) {\n       ...\n       }\n    }\n});\n```\n上面两者等价\n\n\n-  @babel/types： 遍历 AST 的过程中需要创建一些 AST 和判断 AST 的类型\n\n```\nconst types = require('@babel/types');\ntraverse(ast, {\n    CallExpression(path, state) {\n        if ( types.isMemberExpression(path.node.callee)) {\n          \n        }\n    }\n});\n```\n\n-  @babel/template: 简化 AST 创建逻辑\n\n可以遍历 AST，并调用 visitor 函数修改 AST，修改 AST 自然涉及到 AST 的判断、创建、修改等, 这时候就需要 `@babel/types` 了，当需要批量创建 AST 的时候可以使用 `@babel/template` 来简化 AST 创建逻辑\n\n### generate\n\n把AST生成目标代码，并且转换成sourcemap\n\n#### generate的API\n\n- @babel/generate: 把 AST 打印为目标代码字符串,同时生成 sourcemap\n\n``` js\nfunction (ast: Object, opts: GeneratorOptions, code: string): {code, map}\n```\n\n类型声明\n\n```\nexport default function generate(\n    ast: t.Node,\n    opts?: GeneratorOptions,\n    code?: string | { [filename: string]: string },\n): GeneratorResult;\n```\n\noptions 中常用的是 sourceMaps，开启了这个选项才会生成 sourcemap\n\n``` js\nconst { code, map } = generate(ast, { sourceMaps: true })\n```\n- @babel/code-frame: 中途遇到错误想打印代码位置的时候\n\n``` js\nconst result = codeFrameColumns(rawLines, location, {\n  /* options */\n});\n\n```\n\n\n### @babel/core\n\n基于上面的包完成 babel 整体的编译流程\n\n``` js\nconst { transformFileSync } = require('@babel/core');\n\ntransformSync(code, options); // => { code, map, ast } transformFileSync(filename, options); // => { code, map, ast } transformFromAstSync\n```\n\n ### 总结\n \n babel 编译的三个阶段以及每个阶段对应的API\n\n|  stage   | 名称  | 释义|相关的API| 核心的点\n|  ----  | ----  | ----|----| ----|\n| stage1  | parse | 转成AST语法树| @babel/parser|  词法分析（分词）、语法分析（组装AST）|\n| stage2  | transform | 遍历AST，调用transform的各种API进行增删改查| @babel/traverse 、@babel/template、@babel/types| path、scope、visitor|\n| stage3 | generate | 生成sourcemap| @babel/code-frame、@babel/generate|generator、sourcemap|\n\n\n整体能通过`@babel/core`完成编译的流程\n\n 以上提到的api都是`tooling packages`,  这里再提一下 babel 还有`Integration Packages`\n\n#### Integration Packages\n\n [@babel/cli](https://babeljs.io/docs/en/babel-cli)\n \n [@babel/polyfill](https://babeljs.io/docs/en/babel-polyfill)\n\n[@babel/plugin-transform-runtime](https://babeljs.io/docs/en/babel-plugin-transform-runtime)\n\n[@babel/register](https://babeljs.io/docs/en/babel-register)\n\n[@babel/standalone](https://babeljs.io/docs/en/babel-standalone)\n \n\n\n\n\n\n","source":"_posts/编译流程.md","raw":"---\ntitle: 编译流程\ndate: 2022-06-04 20:40:52\ntags: babel\n---\n\n\n## 编译流程\n\n### parse \n\n通过parse 转成AST语法树。 具体是把源代码转成转成机器能够理解的AST，这个过程分为*词法分析*、 *语法分析*\n\n\n#### 词法分析\n\n我们要源码把它分成一个个不能细分的单词（token）的过程称为*词法分析*\n\n#### 语法分析\n\n我们把token 进行递归的组装，生成AST的过程称为*词法分析*\n\n##### AST\n\n\n![AST.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dc91699e4ec4f69971b02b2c0c44651~tplv-k3u1fbpfcp-watermark.image?)\n\n#### parse的API\n\n- @babel/parser\n\n示例\n``` js\nconst parser = require('@babel/parser');\nconst ast = parser.parse(sourceCode, {\n    sourceType: 'unambiguous', // \"script\" | \"module\" | \"unambiguous\"\n    plugins: ['jsx']\n});\n```\n- sourceType的属性值\n`unambiguous` ：根据据内容是否有 import 和 export 来确定是否解析 es module 语法\n`module`： module 是解析 es module 语法\n`script`： 其他都是script\n\n- plugins\n\n如果要解析tsx 模块，那么可以这样来写\n``` js\nrequire(\"@babel/parser\").parse(\"code\",\n{ sourceType: \"module\",\n    plugins: [ \"jsx\", \"typescript\" ]\n })\n```\n\n- parse 类型声明\n\n``` js\nexport function parse(\n  input: string,\n  options?: ParserOptions\n): ParseResult<import(\"@babel/types\").File>;\n\n```\n\n[ParserOptions](https://babeljs.io/docs/en/babel-parser#options)\n\n### transform\n\n遍历AST，调用transform的各种API进行增删改查，遍历的过程中处理到不同的 AST 节点会调用注册的相应的 visitor 函数，visitor 函数里可以对 AST 节点进行增删改\n\n#### transform的API\n\n-  @babel/traverse: 遍历 AST\n\n``` js\ntraverse(ast, {\n    CallExpression:{\n    enter(path,state){}\n     }\n    }\n});\n```\n\n``` js\ntraverse(ast, {\n    CallExpression(path, state) {\n       ...\n       }\n    }\n});\n```\n上面两者等价\n\n\n-  @babel/types： 遍历 AST 的过程中需要创建一些 AST 和判断 AST 的类型\n\n```\nconst types = require('@babel/types');\ntraverse(ast, {\n    CallExpression(path, state) {\n        if ( types.isMemberExpression(path.node.callee)) {\n          \n        }\n    }\n});\n```\n\n-  @babel/template: 简化 AST 创建逻辑\n\n可以遍历 AST，并调用 visitor 函数修改 AST，修改 AST 自然涉及到 AST 的判断、创建、修改等, 这时候就需要 `@babel/types` 了，当需要批量创建 AST 的时候可以使用 `@babel/template` 来简化 AST 创建逻辑\n\n### generate\n\n把AST生成目标代码，并且转换成sourcemap\n\n#### generate的API\n\n- @babel/generate: 把 AST 打印为目标代码字符串,同时生成 sourcemap\n\n``` js\nfunction (ast: Object, opts: GeneratorOptions, code: string): {code, map}\n```\n\n类型声明\n\n```\nexport default function generate(\n    ast: t.Node,\n    opts?: GeneratorOptions,\n    code?: string | { [filename: string]: string },\n): GeneratorResult;\n```\n\noptions 中常用的是 sourceMaps，开启了这个选项才会生成 sourcemap\n\n``` js\nconst { code, map } = generate(ast, { sourceMaps: true })\n```\n- @babel/code-frame: 中途遇到错误想打印代码位置的时候\n\n``` js\nconst result = codeFrameColumns(rawLines, location, {\n  /* options */\n});\n\n```\n\n\n### @babel/core\n\n基于上面的包完成 babel 整体的编译流程\n\n``` js\nconst { transformFileSync } = require('@babel/core');\n\ntransformSync(code, options); // => { code, map, ast } transformFileSync(filename, options); // => { code, map, ast } transformFromAstSync\n```\n\n ### 总结\n \n babel 编译的三个阶段以及每个阶段对应的API\n\n|  stage   | 名称  | 释义|相关的API| 核心的点\n|  ----  | ----  | ----|----| ----|\n| stage1  | parse | 转成AST语法树| @babel/parser|  词法分析（分词）、语法分析（组装AST）|\n| stage2  | transform | 遍历AST，调用transform的各种API进行增删改查| @babel/traverse 、@babel/template、@babel/types| path、scope、visitor|\n| stage3 | generate | 生成sourcemap| @babel/code-frame、@babel/generate|generator、sourcemap|\n\n\n整体能通过`@babel/core`完成编译的流程\n\n 以上提到的api都是`tooling packages`,  这里再提一下 babel 还有`Integration Packages`\n\n#### Integration Packages\n\n [@babel/cli](https://babeljs.io/docs/en/babel-cli)\n \n [@babel/polyfill](https://babeljs.io/docs/en/babel-polyfill)\n\n[@babel/plugin-transform-runtime](https://babeljs.io/docs/en/babel-plugin-transform-runtime)\n\n[@babel/register](https://babeljs.io/docs/en/babel-register)\n\n[@babel/standalone](https://babeljs.io/docs/en/babel-standalone)\n \n\n\n\n\n\n","slug":"编译流程","published":1,"updated":"2022-06-04T12:41:03.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3zvhuz8000ikiwx1wj00hlx","content":"<h2 id=\"编译流程\"><a href=\"#编译流程\" class=\"headerlink\" title=\"编译流程\"></a>编译流程</h2><h3 id=\"parse\"><a href=\"#parse\" class=\"headerlink\" title=\"parse\"></a>parse</h3><p>通过parse 转成AST语法树。 具体是把源代码转成转成机器能够理解的AST，这个过程分为<em>词法分析</em>、 <em>语法分析</em></p>\n<h4 id=\"词法分析\"><a href=\"#词法分析\" class=\"headerlink\" title=\"词法分析\"></a>词法分析</h4><p>我们要源码把它分成一个个不能细分的单词（token）的过程称为<em>词法分析</em></p>\n<h4 id=\"语法分析\"><a href=\"#语法分析\" class=\"headerlink\" title=\"语法分析\"></a>语法分析</h4><p>我们把token 进行递归的组装，生成AST的过程称为<em>词法分析</em></p>\n<h5 id=\"AST\"><a href=\"#AST\" class=\"headerlink\" title=\"AST\"></a>AST</h5><p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dc91699e4ec4f69971b02b2c0c44651~tplv-k3u1fbpfcp-watermark.image\" alt=\"AST.png\"></p>\n<h4 id=\"parse的API\"><a href=\"#parse的API\" class=\"headerlink\" title=\"parse的API\"></a>parse的API</h4><ul>\n<li>@babel&#x2F;parser</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> parser = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;@babel/parser&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ast = parser.<span class=\"title function_\">parse</span>(sourceCode, &#123;</span><br><span class=\"line\">    <span class=\"attr\">sourceType</span>: <span class=\"string\">&#x27;unambiguous&#x27;</span>, <span class=\"comment\">// &quot;script&quot; | &quot;module&quot; | &quot;unambiguous&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [<span class=\"string\">&#x27;jsx&#x27;</span>]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>sourceType的属性值<br><code>unambiguous</code> ：根据据内容是否有 import 和 export 来确定是否解析 es module 语法<br><code>module</code>： module 是解析 es module 语法<br><code>script</code>： 其他都是script</p>\n</li>\n<li><p>plugins</p>\n</li>\n</ul>\n<p>如果要解析tsx 模块，那么可以这样来写</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@babel/parser&quot;</span>).<span class=\"title function_\">parse</span>(<span class=\"string\">&quot;code&quot;</span>,</span><br><span class=\"line\">&#123; <span class=\"attr\">sourceType</span>: <span class=\"string\">&quot;module&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [ <span class=\"string\">&quot;jsx&quot;</span>, <span class=\"string\">&quot;typescript&quot;</span> ]</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>parse 类型声明</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">parse</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  input: string,</span></span><br><span class=\"line\"><span class=\"params\">  options?: ParserOptions</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">ParseResult</span>&lt;<span class=\"title function_\">import</span>(<span class=\"string\">&quot;@babel/types&quot;</span>).<span class=\"property\">File</span>&gt;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://babeljs.io/docs/en/babel-parser#options\">ParserOptions</a></p>\n<h3 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a>transform</h3><p>遍历AST，调用transform的各种API进行增删改查，遍历的过程中处理到不同的 AST 节点会调用注册的相应的 visitor 函数，visitor 函数里可以对 AST 节点进行增删改</p>\n<h4 id=\"transform的API\"><a href=\"#transform的API\" class=\"headerlink\" title=\"transform的API\"></a>transform的API</h4><ul>\n<li>@babel&#x2F;traverse: 遍历 AST</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">traverse</span>(ast, &#123;</span><br><span class=\"line\">    <span class=\"title class_\">CallExpression</span>:&#123;</span><br><span class=\"line\">    <span class=\"title function_\">enter</span>(<span class=\"params\">path,state</span>)&#123;&#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">traverse</span>(ast, &#123;</span><br><span class=\"line\">    <span class=\"title class_\">CallExpression</span>(path, state) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面两者等价</p>\n<ul>\n<li>@babel&#x2F;types： 遍历 AST 的过程中需要创建一些 AST 和判断 AST 的类型</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const types = require(&#x27;@babel/types&#x27;);</span><br><span class=\"line\">traverse(ast, &#123;</span><br><span class=\"line\">    CallExpression(path, state) &#123;</span><br><span class=\"line\">        if ( types.isMemberExpression(path.node.callee)) &#123;</span><br><span class=\"line\">          </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>@babel&#x2F;template: 简化 AST 创建逻辑</li>\n</ul>\n<p>可以遍历 AST，并调用 visitor 函数修改 AST，修改 AST 自然涉及到 AST 的判断、创建、修改等, 这时候就需要 <code>@babel/types</code> 了，当需要批量创建 AST 的时候可以使用 <code>@babel/template</code> 来简化 AST 创建逻辑</p>\n<h3 id=\"generate\"><a href=\"#generate\" class=\"headerlink\" title=\"generate\"></a>generate</h3><p>把AST生成目标代码，并且转换成sourcemap</p>\n<h4 id=\"generate的API\"><a href=\"#generate的API\" class=\"headerlink\" title=\"generate的API\"></a>generate的API</h4><ul>\n<li>@babel&#x2F;generate: 把 AST 打印为目标代码字符串,同时生成 sourcemap</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> (<span class=\"params\">ast: <span class=\"built_in\">Object</span>, opts: GeneratorOptions, code: string</span>): &#123;code, map&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类型声明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default function generate(</span><br><span class=\"line\">    ast: t.Node,</span><br><span class=\"line\">    opts?: GeneratorOptions,</span><br><span class=\"line\">    code?: string | &#123; [filename: string]: string &#125;,</span><br><span class=\"line\">): GeneratorResult;</span><br></pre></td></tr></table></figure>\n\n<p>options 中常用的是 sourceMaps，开启了这个选项才会生成 sourcemap</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; code, map &#125; = <span class=\"title function_\">generate</span>(ast, &#123; <span class=\"attr\">sourceMaps</span>: <span class=\"literal\">true</span> &#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>@babel&#x2F;code-frame: 中途遇到错误想打印代码位置的时候</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> result = <span class=\"title function_\">codeFrameColumns</span>(rawLines, location, &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* options */</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"babel-x2F-core\"><a href=\"#babel-x2F-core\" class=\"headerlink\" title=\"@babel&#x2F;core\"></a>@babel&#x2F;core</h3><p>基于上面的包完成 babel 整体的编译流程</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; transformFileSync &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;@babel/core&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">transformSync</span>(code, options); <span class=\"comment\">// =&gt; &#123; code, map, ast &#125; transformFileSync(filename, options); // =&gt; &#123; code, map, ast &#125; transformFromAstSync</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p> babel 编译的三个阶段以及每个阶段对应的API</p>\n<table>\n<thead>\n<tr>\n<th>stage</th>\n<th>名称</th>\n<th>释义</th>\n<th>相关的API</th>\n<th>核心的点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>stage1</td>\n<td>parse</td>\n<td>转成AST语法树</td>\n<td>@babel&#x2F;parser</td>\n<td>词法分析（分词）、语法分析（组装AST）</td>\n</tr>\n<tr>\n<td>stage2</td>\n<td>transform</td>\n<td>遍历AST，调用transform的各种API进行增删改查</td>\n<td>@babel&#x2F;traverse 、@babel&#x2F;template、@babel&#x2F;types</td>\n<td>path、scope、visitor</td>\n</tr>\n<tr>\n<td>stage3</td>\n<td>generate</td>\n<td>生成sourcemap</td>\n<td>@babel&#x2F;code-frame、@babel&#x2F;generate</td>\n<td>generator、sourcemap</td>\n</tr>\n</tbody></table>\n<p>整体能通过<code>@babel/core</code>完成编译的流程</p>\n<p> 以上提到的api都是<code>tooling packages</code>,  这里再提一下 babel 还有<code>Integration Packages</code></p>\n<h4 id=\"Integration-Packages\"><a href=\"#Integration-Packages\" class=\"headerlink\" title=\"Integration Packages\"></a>Integration Packages</h4><p> <a href=\"https://babeljs.io/docs/en/babel-cli\">@babel&#x2F;cli</a></p>\n<p> <a href=\"https://babeljs.io/docs/en/babel-polyfill\">@babel&#x2F;polyfill</a></p>\n<p><a href=\"https://babeljs.io/docs/en/babel-plugin-transform-runtime\">@babel&#x2F;plugin-transform-runtime</a></p>\n<p><a href=\"https://babeljs.io/docs/en/babel-register\">@babel&#x2F;register</a></p>\n<p><a href=\"https://babeljs.io/docs/en/babel-standalone\">@babel&#x2F;standalone</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"编译流程\"><a href=\"#编译流程\" class=\"headerlink\" title=\"编译流程\"></a>编译流程</h2><h3 id=\"parse\"><a href=\"#parse\" class=\"headerlink\" title=\"parse\"></a>parse</h3><p>通过parse 转成AST语法树。 具体是把源代码转成转成机器能够理解的AST，这个过程分为<em>词法分析</em>、 <em>语法分析</em></p>\n<h4 id=\"词法分析\"><a href=\"#词法分析\" class=\"headerlink\" title=\"词法分析\"></a>词法分析</h4><p>我们要源码把它分成一个个不能细分的单词（token）的过程称为<em>词法分析</em></p>\n<h4 id=\"语法分析\"><a href=\"#语法分析\" class=\"headerlink\" title=\"语法分析\"></a>语法分析</h4><p>我们把token 进行递归的组装，生成AST的过程称为<em>词法分析</em></p>\n<h5 id=\"AST\"><a href=\"#AST\" class=\"headerlink\" title=\"AST\"></a>AST</h5><p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dc91699e4ec4f69971b02b2c0c44651~tplv-k3u1fbpfcp-watermark.image\" alt=\"AST.png\"></p>\n<h4 id=\"parse的API\"><a href=\"#parse的API\" class=\"headerlink\" title=\"parse的API\"></a>parse的API</h4><ul>\n<li>@babel&#x2F;parser</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> parser = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;@babel/parser&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ast = parser.<span class=\"title function_\">parse</span>(sourceCode, &#123;</span><br><span class=\"line\">    <span class=\"attr\">sourceType</span>: <span class=\"string\">&#x27;unambiguous&#x27;</span>, <span class=\"comment\">// &quot;script&quot; | &quot;module&quot; | &quot;unambiguous&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [<span class=\"string\">&#x27;jsx&#x27;</span>]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>sourceType的属性值<br><code>unambiguous</code> ：根据据内容是否有 import 和 export 来确定是否解析 es module 语法<br><code>module</code>： module 是解析 es module 语法<br><code>script</code>： 其他都是script</p>\n</li>\n<li><p>plugins</p>\n</li>\n</ul>\n<p>如果要解析tsx 模块，那么可以这样来写</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@babel/parser&quot;</span>).<span class=\"title function_\">parse</span>(<span class=\"string\">&quot;code&quot;</span>,</span><br><span class=\"line\">&#123; <span class=\"attr\">sourceType</span>: <span class=\"string\">&quot;module&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [ <span class=\"string\">&quot;jsx&quot;</span>, <span class=\"string\">&quot;typescript&quot;</span> ]</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>parse 类型声明</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">parse</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  input: string,</span></span><br><span class=\"line\"><span class=\"params\">  options?: ParserOptions</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">ParseResult</span>&lt;<span class=\"title function_\">import</span>(<span class=\"string\">&quot;@babel/types&quot;</span>).<span class=\"property\">File</span>&gt;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://babeljs.io/docs/en/babel-parser#options\">ParserOptions</a></p>\n<h3 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a>transform</h3><p>遍历AST，调用transform的各种API进行增删改查，遍历的过程中处理到不同的 AST 节点会调用注册的相应的 visitor 函数，visitor 函数里可以对 AST 节点进行增删改</p>\n<h4 id=\"transform的API\"><a href=\"#transform的API\" class=\"headerlink\" title=\"transform的API\"></a>transform的API</h4><ul>\n<li>@babel&#x2F;traverse: 遍历 AST</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">traverse</span>(ast, &#123;</span><br><span class=\"line\">    <span class=\"title class_\">CallExpression</span>:&#123;</span><br><span class=\"line\">    <span class=\"title function_\">enter</span>(<span class=\"params\">path,state</span>)&#123;&#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">traverse</span>(ast, &#123;</span><br><span class=\"line\">    <span class=\"title class_\">CallExpression</span>(path, state) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面两者等价</p>\n<ul>\n<li>@babel&#x2F;types： 遍历 AST 的过程中需要创建一些 AST 和判断 AST 的类型</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const types = require(&#x27;@babel/types&#x27;);</span><br><span class=\"line\">traverse(ast, &#123;</span><br><span class=\"line\">    CallExpression(path, state) &#123;</span><br><span class=\"line\">        if ( types.isMemberExpression(path.node.callee)) &#123;</span><br><span class=\"line\">          </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>@babel&#x2F;template: 简化 AST 创建逻辑</li>\n</ul>\n<p>可以遍历 AST，并调用 visitor 函数修改 AST，修改 AST 自然涉及到 AST 的判断、创建、修改等, 这时候就需要 <code>@babel/types</code> 了，当需要批量创建 AST 的时候可以使用 <code>@babel/template</code> 来简化 AST 创建逻辑</p>\n<h3 id=\"generate\"><a href=\"#generate\" class=\"headerlink\" title=\"generate\"></a>generate</h3><p>把AST生成目标代码，并且转换成sourcemap</p>\n<h4 id=\"generate的API\"><a href=\"#generate的API\" class=\"headerlink\" title=\"generate的API\"></a>generate的API</h4><ul>\n<li>@babel&#x2F;generate: 把 AST 打印为目标代码字符串,同时生成 sourcemap</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> (<span class=\"params\">ast: <span class=\"built_in\">Object</span>, opts: GeneratorOptions, code: string</span>): &#123;code, map&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类型声明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default function generate(</span><br><span class=\"line\">    ast: t.Node,</span><br><span class=\"line\">    opts?: GeneratorOptions,</span><br><span class=\"line\">    code?: string | &#123; [filename: string]: string &#125;,</span><br><span class=\"line\">): GeneratorResult;</span><br></pre></td></tr></table></figure>\n\n<p>options 中常用的是 sourceMaps，开启了这个选项才会生成 sourcemap</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; code, map &#125; = <span class=\"title function_\">generate</span>(ast, &#123; <span class=\"attr\">sourceMaps</span>: <span class=\"literal\">true</span> &#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>@babel&#x2F;code-frame: 中途遇到错误想打印代码位置的时候</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> result = <span class=\"title function_\">codeFrameColumns</span>(rawLines, location, &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* options */</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"babel-x2F-core\"><a href=\"#babel-x2F-core\" class=\"headerlink\" title=\"@babel&#x2F;core\"></a>@babel&#x2F;core</h3><p>基于上面的包完成 babel 整体的编译流程</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; transformFileSync &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;@babel/core&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">transformSync</span>(code, options); <span class=\"comment\">// =&gt; &#123; code, map, ast &#125; transformFileSync(filename, options); // =&gt; &#123; code, map, ast &#125; transformFromAstSync</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p> babel 编译的三个阶段以及每个阶段对应的API</p>\n<table>\n<thead>\n<tr>\n<th>stage</th>\n<th>名称</th>\n<th>释义</th>\n<th>相关的API</th>\n<th>核心的点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>stage1</td>\n<td>parse</td>\n<td>转成AST语法树</td>\n<td>@babel&#x2F;parser</td>\n<td>词法分析（分词）、语法分析（组装AST）</td>\n</tr>\n<tr>\n<td>stage2</td>\n<td>transform</td>\n<td>遍历AST，调用transform的各种API进行增删改查</td>\n<td>@babel&#x2F;traverse 、@babel&#x2F;template、@babel&#x2F;types</td>\n<td>path、scope、visitor</td>\n</tr>\n<tr>\n<td>stage3</td>\n<td>generate</td>\n<td>生成sourcemap</td>\n<td>@babel&#x2F;code-frame、@babel&#x2F;generate</td>\n<td>generator、sourcemap</td>\n</tr>\n</tbody></table>\n<p>整体能通过<code>@babel/core</code>完成编译的流程</p>\n<p> 以上提到的api都是<code>tooling packages</code>,  这里再提一下 babel 还有<code>Integration Packages</code></p>\n<h4 id=\"Integration-Packages\"><a href=\"#Integration-Packages\" class=\"headerlink\" title=\"Integration Packages\"></a>Integration Packages</h4><p> <a href=\"https://babeljs.io/docs/en/babel-cli\">@babel&#x2F;cli</a></p>\n<p> <a href=\"https://babeljs.io/docs/en/babel-polyfill\">@babel&#x2F;polyfill</a></p>\n<p><a href=\"https://babeljs.io/docs/en/babel-plugin-transform-runtime\">@babel&#x2F;plugin-transform-runtime</a></p>\n<p><a href=\"https://babeljs.io/docs/en/babel-register\">@babel&#x2F;register</a></p>\n<p><a href=\"https://babeljs.io/docs/en/babel-standalone\">@babel&#x2F;standalone</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl3zvhuz7000gkiwx6agm6jfa","category_id":"cl3zvhuz9000jkiwx5uuuh4pp","_id":"cl3zvhuza000pkiwx007j3e9p"}],"PostTag":[{"post_id":"cl3zvhuys0000kiwx1c4uewpz","tag_id":"cl3zvhuyz0002kiwxhs5117te","_id":"cl3zvhuz30007kiwxawm26rmm"},{"post_id":"cl3zvhuyx0001kiwxbsnd6qrl","tag_id":"cl3zvhuz20006kiwxde5ihm2i","_id":"cl3zvhuz5000ckiwx01sj4633"},{"post_id":"cl3zvhuz4000bkiwx37iha1mb","tag_id":"cl3zvhuz4000akiwx1bm570sk","_id":"cl3zvhuz7000fkiwx87hofiuk"},{"post_id":"cl3zvhuz00003kiwxak9t8ute","tag_id":"cl3zvhuz4000akiwx1bm570sk","_id":"cl3zvhuz7000hkiwx3z7g1hom"},{"post_id":"cl3zvhuz10004kiwx12qmeary","tag_id":"cl3zvhuz6000ekiwx4f7bfqef","_id":"cl3zvhuz9000lkiwx0pxkbv8p"},{"post_id":"cl3zvhuz8000ikiwx1wj00hlx","tag_id":"cl3zvhuz6000ekiwx4f7bfqef","_id":"cl3zvhuza000mkiwx5fde486p"},{"post_id":"cl3zvhuz20005kiwxeehpbipp","tag_id":"cl3zvhuz9000kkiwx4gua2xog","_id":"cl3zvhuza000okiwxcxz7e3sr"},{"post_id":"cl3zvhuz40009kiwx3w49gqnt","tag_id":"cl3zvhuza000nkiwx4lz70c49","_id":"cl3zvhuzb000rkiwx16hkfou5"},{"post_id":"cl3zvhuz6000dkiwx5yfe2662","tag_id":"cl3zvhuz6000ekiwx4f7bfqef","_id":"cl3zvhuzc000tkiwx0spz12fy"},{"post_id":"cl3zvhuz7000gkiwx6agm6jfa","tag_id":"cl3zvhuzc000skiwxfxsc76iv","_id":"cl3zvhuzc000ukiwx0vlcazkn"}],"Tag":[{"name":"Vue","_id":"cl3zvhuyz0002kiwxhs5117te"},{"name":"CSS","_id":"cl3zvhuz20006kiwxde5ihm2i"},{"name":"git","_id":"cl3zvhuz4000akiwx1bm570sk"},{"name":"babel","_id":"cl3zvhuz6000ekiwx4f7bfqef"},{"name":"react 18","_id":"cl3zvhuz9000kkiwx4gua2xog"},{"name":"node","_id":"cl3zvhuza000nkiwx4lz70c49"},{"name":"REPL","_id":"cl3zvhuzc000skiwxfxsc76iv"}]}}