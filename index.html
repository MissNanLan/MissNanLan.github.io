<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <title>南蓝的技术博客 | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="header">
    <a class="logo" href="/">南蓝的技术博客</a>
    <ul class="nav">
        
        <li><a href="/">首页</a></li>
        
        <li><a href="/archives">归档</a></li>
        
        <li><a href="/about">关于</a></li>
        
    </ul>
</div>
                
                <div class="post-list">
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/github-%E5%8D%A1%E7%89%87%E7%BB%9F%E8%AE%A1/">github 卡片统计</a>
        <div class="post-except">
            小秘诀新建一个与自己 github 同名的仓库，因为同名的仓库是一个特殊的仓库，README.md 将会出现在首页
github 卡片统计利用第一个开源库github-readme-statsGitHub Extra Pins1/api/pin?username=anuraghazra&amp;repo=github-readme-stats
点击这里测试

GitHub Stats Card1/api?username=MissNanLan

点击这里测试


隐藏个人统计
            <a class="read-more" href="/2022/06/04/github-%E5%8D%A1%E7%89%87%E7%BB%9F%E8%AE%A1/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/git/">#git</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/">编译流程</a>
        <div class="post-except">
            编译流程parse通过parse 转成AST语法树。 具体是把源代码转成转成机器能够理解的AST，这个过程分为词法分析、 语法分析
词法分析我们要源码把它分成一个个不能细分的单词（token）的过程称为词法分析
语法分析我们把token 进行递归的组装，生成AST的过程称为词法分析
AST
parse的API
@babel&#x2F;parser

示例
12345const parser = require(&#x27;@babel/parser&#x27;);const 
            <a class="read-more" href="/2022/06/04/%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/babel/">#babel</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/%E5%A6%82%E4%BD%95%E5%9C%A8git%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-keys/">如何在git本地配置多个SSH keys</a>
        <div class="post-except">
            背景公司用 gitlab，git 的地址用的 ssh 地址。众所周知，用 ssh 地址的话则需要在本地产生一个私钥和公钥；而自己的项目用的是 github，git 也用的是 ssh 地址那么这个时候小心你的 .ssh 不要被覆盖了
具体步骤生成一个 github 的 SSH key1ssh-keygen -t rsa -C &#x27;你github绑定的邮箱&#x27; -f ~/.ssh/github_id_rsa

生成一个 gitlab 的 SSH key12ssh-
            <a class="read-more" href="/2022/06/04/%E5%A6%82%E4%BD%95%E5%9C%A8git%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-keys/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/git/">#git</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/plugin/">plugin</a>
        <div class="post-except">
            举一个例子，以写一个自动生成API文档为主
plugin调用插件1234567891011121314151617181920212223242526// index.jsconst &#123; transformFromAstSync &#125; = require(&#x27;@babel/core&#x27;);const  parser = require(&#x27;@babel/parser&#x27;);const autoDocumentPlugin = 
            <a class="read-more" href="/2022/06/04/plugin/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/babel/">#babel</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAbabel-plugin/">如何实现一个babel plugin</a>
        <div class="post-except">
            最近在学zxg_神说要有光的babel通关秘籍
首先推荐一个非常有用的网站
astexplorer
这个网站能我们实现一个plugin 以及AST的分类图能给我们写插件提供帮助

无非是对各个AST节点进行逻辑处理，实现我们想要的功能
举例，比如我们要实现自动生成文档
123456789/** * say 你好 * @param name 名字 */ function sayHi (name: string, age: number, a: boolean):string &
            <a class="read-more" href="/2022/06/04/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAbabel-plugin/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/babel/">#babel</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/react-18/">react 18</a>
        <div class="post-except">
            What is Concurrent React（并发渲染）并发模式进行可中断渲染
查阅了一些资料
其目的为了提升帮助React应用保持响应，并优雅地适应用户的设备功能和网络速度
因为有了这个并发渲染，Suspense, transitions, and SSR都是充分并发渲染去构建的
可重用的状态接下来的小版本可能会增加 Offscreen
New Feature: Automatic Batching1ReactDOM.flushSync()

https://githu
            <a class="read-more" href="/2022/06/04/react-18/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/react-18/">#react 18</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E9%94%81%E4%B8%8D%E9%94%81/">依赖版本锁不锁</a>
        <div class="post-except">
            原文链接：依赖版本锁不锁
本来只是看下依赖预打包是怎么回事，然后被迫又重新读了这篇文章。有几点值得思考的
关于依赖版本到底锁不锁，锁？如何保持更新，不锁？如何保持稳定 中间商锁依赖，定期更新，并对此负责
1、 依赖分为node依赖和browser依赖，其实我一直区分不了这两者。后者考虑tree-sharking、产物尺寸等
2、 依赖从一个维度分为间接依赖和直接依赖，锁直接依赖只能解决部分问题
3、目前社区已有的解决方案
1）cnpm提供的bug-versions
2）npm
            <a class="read-more" href="/2022/06/04/%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E9%94%81%E4%B8%8D%E9%94%81/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/background-size-%E5%92%8Cbackground-cover%E7%9A%84%E7%BC%A9%E5%86%99/">background-size 和background-cover的缩写</a>
        <div class="post-except">
            简介 background的缩写其实在工作中经常遇到，但是由于属性颇多，会弄混淆，遂记录下
12background: center / contain no-repeat url(&quot;../../media/examples/firefox-logo.svg&quot;), #eee 35% url(&quot;../../media/examples/lizard.png&quot;);

以上代码我是从MDN拷贝的，能判断以上属性是什么属性的缩写吗。我们从浏览器
            <a class="read-more" href="/2022/06/04/background-size-%E5%92%8Cbackground-cover%E7%9A%84%E7%BC%A9%E5%86%99/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/CSS/">#CSS</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/%E5%88%87%E6%8D%A2node%E7%89%88%E6%9C%AC/">切换node版本</a>
        <div class="post-except">
            n1npm install -g n

1234567891011121314n x.x.x 安装某个版本n lts 安装最新版本n stable 安装稳定版本ltsn rm x.x.x 删除某个版本n use 16.14.2n 可以查看所有已安装的node版本，可以根据上下和回车选择要使用的版本n ls-remote --all 查看服务器上所有可用的版本


n ls-remote --all这个命令真香，可以查看目前所有的node版本
nvmNode 版本管理器是一个用
            <a class="read-more" href="/2022/06/04/%E5%88%87%E6%8D%A2node%E7%89%88%E6%9C%AC/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/node/">#node</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/03/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81/">Vue的双向绑定和单向数据流</a>
        <div class="post-except">
            五一假期在家补了课，看到双向绑定与单向数据流的概念。瓦特，我之前以为Vue的V-model就是双向数据流，其实不然,下面让我仔细来看看


双向绑定简而言之，双向绑定就是model的更新会触发view的更新，view的更新会触发model的更新，它们的作用是相互的
单向数据流简而言之，单向数据流就是model的更新会触发view的更新，view的更新不会触发model的更新，它们的作用是单向的
这不是废话吗，谁都知道的
下面就是真正的干货了，板凳坐好

Vue是单向数据流，不
            <a class="read-more" href="/2022/06/03/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.03</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/Vue/">#Vue</a>
            </span>
            
          </div>
        </div>
    </div>
    
</div>

<div class="paginator">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
</div>

                

<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>