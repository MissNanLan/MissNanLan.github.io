<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <title>南蓝的技术博客 | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="header">
    <a class="logo" href="/">南蓝的技术博客</a>
    <ul class="nav">
        
        <li><a href="/">首页</a></li>
        
        <li><a href="/archives">归档</a></li>
        
        <li><a href="/about">关于</a></li>
        
    </ul>
</div>
                
                <div class="post-list">
    
    <div class="post">
        <a class="post-title" href="/2022/06/06/html%E5%B0%8F%E6%8A%80%E5%B7%A7/">html小技巧</a>
        <div class="post-except">
            12345678910111213141516171819202122232425262728// 1、捕获摄像头，user 表示前置摄像头，environment 表示后置摄像头&lt;input type=&quot;file&quot; capture=&quot;user&quot; accept=&quot;image/*&quot; /&gt;// 2、每 10s 刷新一次&lt;meta http-equiv=&quot;refresh&quot; conten
            <a class="read-more" href="/2022/06/06/html%E5%B0%8F%E6%8A%80%E5%B7%A7/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.06</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/html/">#html</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/05/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99/">如何用hexo搭建一个网站</a>
        <div class="post-except">
            几行命令就可以搞定123456$ npm install -g hexo-cli$ npm install hexo$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install

网站目录结构12345678910├── _config.yml  // 配置信息├── package.json├── scaffolds  // 模板文件├── source|   ├── _drafts|   └── _posts└── 
            <a class="read-more" href="/2022/06/05/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.05</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/hexo/">#hexo</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/05/JSX-Element-VS-ReactNode-VS-ReactElement/">JSX.Element VS ReactNode VS ReactElement</a>
        <div class="post-except">
            引起对这个问题好奇的原因是因为，发现在日常开发中，即用了JSX.Element,又用了ReactNode，对此颇有些困惑
stackoverflow也有一样的困惑
ReactNode可以说是最大的层级

我们可以顺着类型声明往上找可以发现
1type ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;
ReactNode是联合类型，由 ReactChild、Rea
            <a class="read-more" href="/2022/06/05/JSX-Element-VS-ReactNode-VS-ReactElement/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.05</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/react/">#react</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/">编译流程</a>
        <div class="post-except">
            编译流程parse通过parse 转成AST语法树。 具体是把源代码转成转成机器能够理解的AST，这个过程分为词法分析、 语法分析
词法分析我们要源码把它分成一个个不能细分的单词（token）的过程称为词法分析
语法分析我们把token 进行递归的组装，生成AST的过程称为词法分析
AST
parse的API
@babel&#x2F;parser

示例
12345const parser = require(&#x27;@babel/parser&#x27;);const 
            <a class="read-more" href="/2022/06/04/%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/babel/">#babel</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/%E5%A6%82%E4%BD%95%E5%9C%A8git%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-keys/">如何在git本地配置多个SSH keys</a>
        <div class="post-except">
            背景公司用 gitlab，git 的地址用的 ssh 地址。众所周知，用 ssh 地址的话则需要在本地产生一个私钥和公钥；而自己的项目用的是 github，git 也用的是 ssh 地址那么这个时候小心你的 .ssh 不要被覆盖了
具体步骤生成一个 github 的 SSH key1ssh-keygen -t rsa -C &#x27;你github绑定的邮箱&#x27; -f ~/.ssh/github_id_rsa

生成一个 gitlab 的 SSH key12ssh-
            <a class="read-more" href="/2022/06/04/%E5%A6%82%E4%BD%95%E5%9C%A8git%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-keys/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/git/">#git</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/plugin/">plugin</a>
        <div class="post-except">
            举一个例子，以写一个自动生成API文档为主
plugin调用插件1234567891011121314151617181920212223242526// index.jsconst &#123; transformFromAstSync &#125; = require(&#x27;@babel/core&#x27;);const  parser = require(&#x27;@babel/parser&#x27;);const autoDocumentPlugin = 
            <a class="read-more" href="/2022/06/04/plugin/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/babel/">#babel</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAbabel-plugin/">如何实现一个babel plugin</a>
        <div class="post-except">
            最近在学zxg_神说要有光的 babel 通关秘籍
首先推荐一个非常有用的网站
astexplorer
这个网站能我们实现一个 plugin 以及 AST 的分类图能给我们写插件提供帮助

无非是对各个 AST 节点进行逻辑处理，实现我们想要的功能
举例，比如我们要实现自动生成文档
12345678/** * say 你好 * @param name 名字 */function sayHi(name: string, age: number, a: boolean): str
            <a class="read-more" href="/2022/06/04/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAbabel-plugin/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/babel/">#babel</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/react-18/">react 18</a>
        <div class="post-except">
            What is Concurrent React（并发渲染）并发模式进行可中断渲染
查阅了一些资料
其目的为了提升帮助React应用保持响应，并优雅地适应用户的设备功能和网络速度
因为有了这个并发渲染，Suspense, transitions, and SSR都是充分并发渲染去构建的
可重用的状态接下来的小版本可能会增加 Offscreen
New Feature: Automatic Batching1ReactDOM.flushSync()

https://githu
            <a class="read-more" href="/2022/06/04/react-18/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/react-18/">#react 18</a>
            </span>
            
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E9%94%81%E4%B8%8D%E9%94%81/">依赖版本锁不锁</a>
        <div class="post-except">
            原文链接：依赖版本锁不锁
本来只是看下依赖预打包是怎么回事，然后被迫又重新读了这篇文章。有几点值得思考的
关于依赖版本到底锁不锁，锁？如何保持更新，不锁？如何保持稳定 中间商锁依赖，定期更新，并对此负责
1、 依赖分为node依赖和browser依赖，其实我一直区分不了这两者。后者考虑tree-sharking、产物尺寸等
2、 依赖从一个维度分为间接依赖和直接依赖，锁直接依赖只能解决部分问题
3、目前社区已有的解决方案
1）cnpm提供的bug-versions
2）npm
            <a class="read-more" href="/2022/06/04/%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E9%94%81%E4%B8%8D%E9%94%81/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
          </div>
        </div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2022/06/04/background-size-%E5%92%8Cbackground-cover%E7%9A%84%E7%BC%A9%E5%86%99/">background-size 和background-cover的缩写</a>
        <div class="post-except">
            简介 background的缩写其实在工作中经常遇到，但是由于属性颇多，会弄混淆，遂记录下
12background: center / contain no-repeat url(&quot;../../media/examples/firefox-logo.svg&quot;), #eee 35% url(&quot;../../media/examples/lizard.png&quot;);

以上代码我是从MDN拷贝的，能判断以上属性是什么属性的缩写吗。我们从浏览器
            <a class="read-more" href="/2022/06/04/background-size-%E5%92%8Cbackground-cover%E7%9A%84%E7%BC%A9%E5%86%99/"> ... </a>
        </div>
        <div class="post-footer">
          <div class="post-date">2022.06.04</div>
          <div class="post-tag">   
           
            <span class="post-tag-item">
                <a href="/tags/CSS/">#CSS</a>
            </span>
            
          </div>
        </div>
    </div>
    
</div>

<div class="paginator">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
</div>

                

<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>